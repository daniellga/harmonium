---
title: HResampler
---

A resampler. \

#### Asynchronous Resamplers

The resampling is based on band-limited interpolation using sinc interpolation filters. The sinc interpolation upsamples by an adjustable factor,
and then the new sample points are calculated by interpolating between these points. \
The resampling ratio can be updated at any time. \

* `SincFixedIn` \

* `SincFixedOut` \

* `FastFixedIn` \

* `FastFixedOut` \

#### Synchronous Resamplers

Is implemented via FFT. The data is FFTed, the spectrum modified, and then inverse FFTed to get the resampled data. \
This type of resampler is considerably faster but doesn’t support changing the resampling ratio. \

* `FftFixedIn` \

* `FftFixedInOut` \

* `FftFixedOut` \

# Methods

## new_fft

`new_fft(sr_in: integer, sr_out: integer, chunk_size: integer, sub_chunks: integer, nbr_channels: integer, res_type: HResamplerType, dtype: HDataType) -> HResampler` \

Creates a new FFT type HResampler. \
Supports any of  `[fft_fixed_in, fft_fixed_in_out, fft_fixed_out]` `HResamplerType`. \
The resampling is done by FFTing the input data. The spectrum is then extended or truncated as well as multiplied with an antialiasing
filter before it’s inverse transformed to get the resampled waveforms. \

* `fft_fixed_in` \
A synchronous resampler that needs a fixed number of audio frames for input and returns a variable number of frames. \

* `fft_fixed_in_out` \
A synchronous resampler that accepts a fixed number of audio frames for input and returns a fixed number of frames. \

* `fft_fixed_out` \
A synchronous resampler that needs a fixed number of audio frames for input and returns a variable number of frames. \

#### Arguments

* `sr_in` \
The input sampling rate in hz. \
* `sr_out` \
The output sampling rate in hz. \
* `chunk_size` \
Chunks size of input or output data in frames. \
It can be used as input or output, depending on `HResamplerType`. \
* `sub_chunks` \
Desired number of subchunks for processing, actual number may be different. \
* `nbr_channels` \
Number of channels in input and output. \
Must be the same number of channels as the `HAudio` that will be processed by the `HResampler`. \
* `res_type` \
An `HResamplerType` to indicate which type of `HResampler` to be created. \
* `dtype` \
A float `HDataType` to indicate the dtype that the `HResampler` will be working with. \
Must be the same as the `HAudio`'s dtype that will be processed by the `HResampler`. \

#### Returns

A FFT type `HResampler`. \

#### Examples

```r
sr_in = 48000L
sr_out = 44100L
chunk_size = 1024L
sub_chunks = 2L
nbr_channels = 2L
res_type = HResamplerType$fft_fixed_in
dtype = HDataType$float32

hresampler = HResampler$new_fft(sr_in, sr_out, chunk_size, sub_chunks, nbr_channels, res_type, dtype)
```

_________

## new_sinc

`new_sinc(resample_ratio: double, max_resample_ratio_relative: double, parameters: HSincInterpolationParams, chunk_size: integer, nbr_channels: integer, res_type: HResamplerType, dtype: HDataType) -> HResampler` \

Creates a new Sinc type HResampler. \
Supports any of  `[sinc_fixed_in, sinc_fixed_out]` `HResamplerType`. \
The resampling is done by creating a number of intermediate points (defined by oversampling_factor) by sinc interpolation. \
The new samples are then calculated by interpolating between these points. \

* `sinc_fixed_in` \
An asynchronous resampler that accepts a fixed number of audio frames for input and returns a variable number of frames. \

* `sinc_fixed_out` \
An asynchronous resampler that accepts a variable number of audio frames for input nad returns a fixed number of frames. \

#### Arguments

* `resample_ratio` \
The output's sampling rate divided by the input's sampling rate.
* `max_resample_ratio_relative` \
Maximum ratio that can be set with `set_resample_ratio` relative to `resample_ratio`, must be >= 1.0. The minimum relative \
ratio is the reciprocal of the maximum. For example, with `max_resample_ratio_relative` of 10.0, the ratio can be set between \
`resample_ratio * 10.0` and `resample_ratio / 10.0`.
* `parameters` \
An `HSincInterpolationParams`. Parameters for interpolation. \
* `chunk_size` \
Chunks size of input or output data in frames. \
* `nbr_channels` \
Number of channels in input and output. \
Must be the same number of channels as the `HAudio` that will be processed by the `HResampler`. \
* `res_type` \
An `HResamplerType`. Indicates which type of `HResampler` to be created. \
* `dtype` \
A float `HDataType` to indicate the dtype that the `HResampler` will be working with. \
Must be the same as the `HAudio`'s dtype that will be processed by the `HResampler`. \

#### Returns

A Sinc type `HResampler`. \

#### Examples

```r
sr_in = 44100L
sr_out = 48000L
resample_ratio = sr_out / sr_in
max_resample_ratio_relative = 2
hparams = HSincInterpolationParams$new(256, 0.95, 256, "linear", "blackmanharris2")
chunk_size = 512L
nbr_channels = 2L
res_type = HResamplerType$sinc_fixed_out
dtype = HDataType$float32

res = HResampler$new_sinc(resample_ratio, max_resample_ratio_relative, hparams, chunk_size, nbr_channels, res_type, dtype)
```

_________

## new_fast

`new_sinc(resample_ratio: double, max_resample_ratio_relative: double, pol_deg: HPolynomialDegree, chunk_size: integer, nbr_channels: integer, res_type: HResamplerType, dtype: HDataType) -> HResampler` \

Creates a new Fast type HResampler. \
Supports any of  `[fast_fixed_in, fast_fixed_out]` `HResamplerType`. \
The resampling is done by interpolating between the input samples by fitting polynomials. \
Note that no anti-aliasing filter is used. This makes it run considerably faster than the corresponding `SincFixedIn`, which performs anti-aliasing filtering. The price is that the resampling creates some artefacts \
in the output, mainly at higher frequencies. Use `SincFixedIn` if this can not be tolerated. \

* `fast_fixed_in` \
An asynchronous resampler that accepts a fixed number of audio frames for input and returns a variable number of frames. \

* `fast_fixed_out` \
An asynchronous resampler that accepts a variable number of audio frames for input nad returns a fixed number of frames. \

#### Arguments

* `resample_ratio` \
The output's sampling rate divided by the input's sampling rate.
* `max_resample_ratio_relative` \
Maximum ratio that can be set with `set_resample_ratio` relative to `resample_ratio`, must be >= 1.0. The minimum relative \
ratio is the reciprocal of the maximum. For example, with `max_resample_ratio_relative` of 10.0, the ratio can be set between \
`resample_ratio * 10.0` and `resample_ratio / 10.0`.
* `pol_deg` \
An `HPolynomialDegree`. Used to select the polynomial degree for interpolation. \
* `chunk_size` \
Chunks size of input or output data in frames. \
* `nbr_channels` \
Number of channels in input and output. \
Must be the same number of channels as the `HAudio` that will be processed by the `HResampler`. \
* `res_type` \
An `HResamplerType`. Indicates which type of `HResampler` to be created. \
* `dtype` \
A float `HDataType` to indicate the dtype that the `HResampler` will be working with. \
Must be the same as the `HAudio`'s dtype that will be processed by the `HResampler`. \

#### Returns

A Fast type `HResampler`. \

#### Examples

```r
sr_in = 44100L
sr_out = 48000L
resample_ratio = sr_out / sr_in
max_resample_ratio_relative = 2
pol_deg = HPolynomialDegree$linear
chunk_size = 512L
nbr_channels = 2L
res_type = HResamplerType$fast_fixed_out
dtype = HDataType$float32

res = HResampler$new_fast(resample_ratio, max_resample_ratio_relative, pol_deg, chunk_size, nbr_channels, res_type, dtype)
```

_________

## reset

`reset()` <span style="float: right;"> [source](https://www.github.com/daniellga/harmonium/blob/master/r-harmonium/src/rust/src/./hresampler.rs#L460) </span> \

Reset the resampler state and clear all internal buffers. \

#### Examples

```r
sr_in = 44100L
sr_out = 48000L
resample_ratio = sr_out / sr_in
max_resample_ratio_relative = 2
pol_deg = HPolynomialDegree$linear
chunk_size = 512L
nbr_channels = 2L
res_type = HResamplerType$fast_fixed_out
dtype = HDataType$float32

res = HResampler$new_fast(resample_ratio, max_resample_ratio_relative, pol_deg, chunk_size, nbr_channels, res_type, dtype)
res$reset()
```

_________

## res_type

`res_type() -> HResamplerType` <span style="float: right;"> [source](https://www.github.com/daniellga/harmonium/blob/master/r-harmonium/src/rust/src/./hresampler.rs#L494) </span> \

Gets the `HResampler`'s type as an `HResamplerType`.

#### Returns

An `HResamplerType`.

#### Examples

```r
sr_in = 44100L
sr_out = 48000L
resample_ratio = sr_out / sr_in
max_resample_ratio_relative = 2
pol_deg = HPolynomialDegree$linear
chunk_size = 512L
nbr_channels = 2L
res_type = HResamplerType$fast_fixed_out
dtype = HDataType$float32

res = HResampler$new_fast(resample_ratio, max_resample_ratio_relative, pol_deg, chunk_size, nbr_channels, res_type, dtype)
res$res_type()
```

_________

## dtype

`dtype() -> HDataType` <span style="float: right;"> [source](https://www.github.com/daniellga/harmonium/blob/master/r-harmonium/src/rust/src/./hresampler.rs#L528) </span> \

Gets the `HResampler`'s dtype as an `HDataType`.

#### Returns

An `HDataType`.

#### Examples

```r
sr_in = 44100L
sr_out = 48000L
resample_ratio = sr_out / sr_in
max_resample_ratio_relative = 2
pol_deg = HPolynomialDegree$linear
chunk_size = 512L
nbr_channels = 2L
res_type = HResamplerType$fast_fixed_out
dtype = HDataType$float32

res = HResampler$new_fast(resample_ratio, max_resample_ratio_relative, pol_deg, chunk_size, nbr_channels, res_type, dtype)
res$dtype()
```

_________

## print

`print()` <span style="float: right;"> [source](https://www.github.com/daniellga/harmonium/blob/master/r-harmonium/src/rust/src/./hresampler.rs#L562) </span> \

Print the `HResampler`. \
Differently from R's normal behaviour, `print` doesn't return the value invisibly. \

#### Examples

```r
sr_in = 44100L
sr_out = 48000L
resample_ratio = sr_out / sr_in
max_resample_ratio_relative = 2
pol_deg = HPolynomialDegree$linear
chunk_size = 512L
nbr_channels = 2L
res_type = HResamplerType$fast_fixed_out
dtype = HDataType$float32

res = HResampler$new_fast(resample_ratio, max_resample_ratio_relative, pol_deg, chunk_size, nbr_channels, res_type, dtype)
res$print()

# or similarly:
print(res)
```

_________
