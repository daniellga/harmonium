# Generated by savvy: do not edit by hand
#
# Note:
#   This wrapper file is named as `000-wrappers.R` so that this file is loaded
#   first, which allows users to override the functions defined here (e.g., a
#   print() method for an enum).

#' @useDynLib harmonium, .registration = TRUE
#' @keywords internal
NULL

# Check class and extract the external pointer embedded in the environment
.savvy_extract_ptr <- function(e, class) {
  if(is.null(e)) {
    return(NULL)
  }

  if(inherits(e, class)) {
    e$.ptr
  } else {
    msg <- paste0("Expected ", class, ", got ", class(e)[1])
    stop(msg, call. = FALSE)
  }
}


### wrapper functions for HArray

HArray_len <- function(self) {
  function() {
  .Call(savvy_HArray_len__impl, self)
  }
}

HArray_shape <- function(self) {
  function() {
  .Call(savvy_HArray_shape__impl, self)
  }
}

HArray_ndim <- function(self) {
  function() {
  .Call(savvy_HArray_ndim__impl, self)
  }
}

HArray_slice <- function(self) {
  function(range) {
    .savvy_wrap_HArray(.Call(savvy_HArray_slice__impl, self, range))
  }
}

HArray_print <- function(self) {
  function() {
  invisible(.Call(savvy_HArray_print__impl, self))
  }
}

HArray_eq <- function(self) {
  function(other) {
    other <- .savvy_extract_ptr(other, "HArray")
.Call(savvy_HArray_eq__impl, self, other)
  }
}

HArray_ne <- function(self) {
  function(other) {
    other <- .savvy_extract_ptr(other, "HArray")
.Call(savvy_HArray_ne__impl, self, other)
  }
}

HArray_clone <- function(self) {
  function() {
    .savvy_wrap_HArray(.Call(savvy_HArray_clone__impl, self))
  }
}

HArray_collect <- function(self) {
  function() {
  .Call(savvy_HArray_collect__impl, self)
  }
}

HArray_dtype <- function(self) {
  function() {
    .savvy_wrap_HDataType(.Call(savvy_HArray_dtype__impl, self))
  }
}

HArray_is_shared <- function(self) {
  function() {
  .Call(savvy_HArray_is_shared__impl, self)
  }
}

HArray_mem_adress <- function(self) {
  function() {
  .Call(savvy_HArray_mem_adress__impl, self)
  }
}

HArray_is_standard_layout <- function(self) {
  function() {
  .Call(savvy_HArray_is_standard_layout__impl, self)
  }
}

HArray_invalidate <- function(self) {
  function() {
  invisible(.Call(savvy_HArray_invalidate__impl, self))
  }
}

.savvy_wrap_HArray <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr
    e$len <- HArray_len(ptr)
  e$shape <- HArray_shape(ptr)
  e$ndim <- HArray_ndim(ptr)
  e$slice <- HArray_slice(ptr)
  e$print <- HArray_print(ptr)
  e$eq <- HArray_eq(ptr)
  e$ne <- HArray_ne(ptr)
  e$clone <- HArray_clone(ptr)
  e$collect <- HArray_collect(ptr)
  e$dtype <- HArray_dtype(ptr)
  e$is_shared <- HArray_is_shared(ptr)
  e$mem_adress <- HArray_mem_adress(ptr)
  e$is_standard_layout <- HArray_is_standard_layout(ptr)
  e$invalidate <- HArray_invalidate(ptr)
  
  class(e) <- "HArray"
  e
}


#' HArray
#' An array representation.
#'
#' # Methods
#'
HArray <- new.env(parent = emptyenv())

### associated functions for HArray

HArray$new_from_values <- function(arr, dtype) {
  dtype <- .savvy_extract_ptr(dtype, "HDataType")
  .savvy_wrap_HArray(.Call(savvy_HArray_new_from_values__impl, arr, dtype))
}


### wrapper functions for HAudioOp


.savvy_wrap_HAudioOp <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr
  
  
  class(e) <- "HAudioOp"
  e
}


#' HAudioOp
#' A collection of methods that can be applied to float 1D or 2D `HArray`s which represents audio data.
#'
#' # Methods
#'
HAudioOp <- new.env(parent = emptyenv())

### associated functions for HAudioOp

HAudioOp$nchannels <- function(harray) {
  harray <- .savvy_extract_ptr(harray, "HArray")
.Call(savvy_HAudioOp_nchannels__impl, harray)
}

HAudioOp$nframes <- function(harray) {
  harray <- .savvy_extract_ptr(harray, "HArray")
.Call(savvy_HAudioOp_nframes__impl, harray)
}

HAudioOp$db_to_amplitude <- function(harray, reference, power) {
  harray <- .savvy_extract_ptr(harray, "HArray")
invisible(.Call(savvy_HAudioOp_db_to_amplitude__impl, harray, reference, power))
}

HAudioOp$to_mono <- function(harray) {
  harray <- .savvy_extract_ptr(harray, "HArray")
invisible(.Call(savvy_HAudioOp_to_mono__impl, harray))
}


### wrapper functions for HAudioSink

HAudioSink_append_from_harray <- function(self) {
  function(harray, sr) {
    harray <- .savvy_extract_ptr(harray, "HArray")
invisible(.Call(savvy_HAudioSink_append_from_harray__impl, self, harray, sr))
  }
}

HAudioSink_append_from_file <- function(self) {
  function(fpath) {
  invisible(.Call(savvy_HAudioSink_append_from_file__impl, self, fpath))
  }
}

HAudioSink_clear <- function(self) {
  function() {
  invisible(.Call(savvy_HAudioSink_clear__impl, self))
  }
}

HAudioSink_is_empty <- function(self) {
  function() {
  .Call(savvy_HAudioSink_is_empty__impl, self)
  }
}

HAudioSink_is_paused <- function(self) {
  function() {
  .Call(savvy_HAudioSink_is_paused__impl, self)
  }
}

HAudioSink_len <- function(self) {
  function() {
  .Call(savvy_HAudioSink_len__impl, self)
  }
}

HAudioSink_pause <- function(self) {
  function() {
  invisible(.Call(savvy_HAudioSink_pause__impl, self))
  }
}

HAudioSink_play <- function(self) {
  function() {
  invisible(.Call(savvy_HAudioSink_play__impl, self))
  }
}

HAudioSink_set_speed <- function(self) {
  function(value) {
  invisible(.Call(savvy_HAudioSink_set_speed__impl, self, value))
  }
}

HAudioSink_set_volume <- function(self) {
  function(value) {
  invisible(.Call(savvy_HAudioSink_set_volume__impl, self, value))
  }
}

HAudioSink_skip_one <- function(self) {
  function() {
  invisible(.Call(savvy_HAudioSink_skip_one__impl, self))
  }
}

HAudioSink_sleep_until_end <- function(self) {
  function() {
  invisible(.Call(savvy_HAudioSink_sleep_until_end__impl, self))
  }
}

HAudioSink_speed <- function(self) {
  function() {
  .Call(savvy_HAudioSink_speed__impl, self)
  }
}

HAudioSink_stop <- function(self) {
  function() {
  invisible(.Call(savvy_HAudioSink_stop__impl, self))
  }
}

HAudioSink_try_seek <- function(self) {
  function(pos) {
  invisible(.Call(savvy_HAudioSink_try_seek__impl, self, pos))
  }
}

HAudioSink_volume <- function(self) {
  function() {
  .Call(savvy_HAudioSink_volume__impl, self)
  }
}

.savvy_wrap_HAudioSink <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr
    e$append_from_harray <- HAudioSink_append_from_harray(ptr)
  e$append_from_file <- HAudioSink_append_from_file(ptr)
  e$clear <- HAudioSink_clear(ptr)
  e$is_empty <- HAudioSink_is_empty(ptr)
  e$is_paused <- HAudioSink_is_paused(ptr)
  e$len <- HAudioSink_len(ptr)
  e$pause <- HAudioSink_pause(ptr)
  e$play <- HAudioSink_play(ptr)
  e$set_speed <- HAudioSink_set_speed(ptr)
  e$set_volume <- HAudioSink_set_volume(ptr)
  e$skip_one <- HAudioSink_skip_one(ptr)
  e$sleep_until_end <- HAudioSink_sleep_until_end(ptr)
  e$speed <- HAudioSink_speed(ptr)
  e$stop <- HAudioSink_stop(ptr)
  e$try_seek <- HAudioSink_try_seek(ptr)
  e$volume <- HAudioSink_volume(ptr)
  
  class(e) <- "HAudioSink"
  e
}


#' HAudioSink
#' Handle to a device that outputs sounds.
#'
#' # Methods
#'
HAudioSink <- new.env(parent = emptyenv())

### associated functions for HAudioSink

HAudioSink$new <- function() {
  .savvy_wrap_HAudioSink(.Call(savvy_HAudioSink_new__impl))
}

HAudioSink$audio_default_device <- function() {
.Call(savvy_HAudioSink_audio_default_device__impl)
}

HAudioSink$audio_output_devices <- function() {
.Call(savvy_HAudioSink_audio_output_devices__impl)
}

HAudioSink$audio_supported_configs <- function() {
.Call(savvy_HAudioSink_audio_supported_configs__impl)
}


### wrapper functions for HDataType

HDataType_print <- function(self) {
  function() {
  invisible(.Call(savvy_HDataType_print__impl, self))
  }
}

HDataType_eq <- function(self) {
  function(other) {
    other <- .savvy_extract_ptr(other, "HDataType")
.Call(savvy_HDataType_eq__impl, self, other)
  }
}

HDataType_ne <- function(self) {
  function(other) {
    other <- .savvy_extract_ptr(other, "HDataType")
.Call(savvy_HDataType_ne__impl, self, other)
  }
}

.savvy_wrap_HDataType <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr
    e$print <- HDataType_print(ptr)
  e$eq <- HDataType_eq(ptr)
  e$ne <- HDataType_ne(ptr)
  
  class(e) <- "HDataType"
  e
}


#' HDataType
#' A type representation.
#'
#' Supports `Float32`, `Float64`, `Complex32` and `Complex64` types.
#'
#' # Methods
#'
HDataType <- new.env(parent = emptyenv())
HDataType$Float32 <- .savvy_wrap_HDataType(0L)
HDataType$Float64 <- .savvy_wrap_HDataType(1L)
HDataType$Complex32 <- .savvy_wrap_HDataType(2L)
HDataType$Complex64 <- .savvy_wrap_HDataType(3L)

#' @export
print.HDataType <- function(x, ...) {
  idx <- x$.ptr + 1L
  label <- c("Float32", "Float64", "Complex32", "Complex64")[idx]
  if (is.na(label)) {
    stop("Unexpected value for HDataType", call. = TRUE)
  }
  cat("HDataType::", label, sep = "")
}


### associated functions for HDataType



### wrapper functions for HDecodedAudio

HDecodedAudio_harray <- function(self) {
  function() {
    .savvy_wrap_HArray(.Call(savvy_HDecodedAudio_harray__impl, self))
  }
}

HDecodedAudio_sr <- function(self) {
  function() {
  .Call(savvy_HDecodedAudio_sr__impl, self)
  }
}

HDecodedAudio_invalidate <- function(self) {
  function() {
  invisible(.Call(savvy_HDecodedAudio_invalidate__impl, self))
  }
}

.savvy_wrap_HDecodedAudio <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr
    e$harray <- HDecodedAudio_harray(ptr)
  e$sr <- HDecodedAudio_sr(ptr)
  e$invalidate <- HDecodedAudio_invalidate(ptr)
  
  class(e) <- "HDecodedAudio"
  e
}


#' HDecodedAudio
#' An audio represented by an HArray of samples and its corresponding sampling rate.
#'
#' # Methods
#'
HDecodedAudio <- new.env(parent = emptyenv())

### associated functions for HDecodedAudio



### wrapper functions for HDecoderStream

HDecoderStream_stream <- function(self) {
  function() {
    .savvy_wrap_HArray(.Call(savvy_HDecoderStream_stream__impl, self))
  }
}

.savvy_wrap_HDecoderStream <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr
    e$stream <- HDecoderStream_stream(ptr)
  
  class(e) <- "HDecoderStream"
  e
}


#' HDecoderStream
#' An iterator that decodes audio in streams.
#'
#' # Methods
#'
HDecoderStream <- new.env(parent = emptyenv())

### associated functions for HDecoderStream



### wrapper functions for HFftPlanner

HFftPlanner_fft <- function(self) {
  function(harray) {
    harray <- .savvy_extract_ptr(harray, "HArray")
invisible(.Call(savvy_HFftPlanner_fft__impl, self, harray))
  }
}

HFftPlanner_ifft <- function(self) {
  function(harray) {
    harray <- .savvy_extract_ptr(harray, "HArray")
invisible(.Call(savvy_HFftPlanner_ifft__impl, self, harray))
  }
}

HFftPlanner_dtype <- function(self) {
  function() {
    .savvy_wrap_HDataType(.Call(savvy_HFftPlanner_dtype__impl, self))
  }
}

HFftPlanner_print <- function(self) {
  function() {
  invisible(.Call(savvy_HFftPlanner_print__impl, self))
  }
}

.savvy_wrap_HFftPlanner <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr
    e$fft <- HFftPlanner_fft(ptr)
  e$ifft <- HFftPlanner_ifft(ptr)
  e$dtype <- HFftPlanner_dtype(ptr)
  e$print <- HFftPlanner_print(ptr)
  
  class(e) <- "HFftPlanner"
  e
}


#' HFftPlanner
#' A planner is used to create FFTs. It caches results internally, so when making more than one FFT it is advisable to reuse the same planner.
#'
#' # Methods
#'
HFftPlanner <- new.env(parent = emptyenv())

### associated functions for HFftPlanner

HFftPlanner$new <- function(dtype) {
  dtype <- .savvy_extract_ptr(dtype, "HDataType")
  .savvy_wrap_HFftPlanner(.Call(savvy_HFftPlanner_new__impl, dtype))
}


### wrapper functions for HFile


.savvy_wrap_HFile <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr
  
  
  class(e) <- "HFile"
  e
}


#' HFile
#' A collection of methods designed to streamline input and output operations.
#'
#' # Methods
#'
HFile <- new.env(parent = emptyenv())

### associated functions for HFile

HFile$decode <- function(fpath, dtype) {
  dtype <- .savvy_extract_ptr(dtype, "HDataType")
  .savvy_wrap_HDecodedAudio(.Call(savvy_HFile_decode__impl, fpath, dtype))
}

HFile$decode_stream <- function(fpath, frames, dtype) {
  dtype <- .savvy_extract_ptr(dtype, "HDataType")
  .savvy_wrap_HDecoderStream(.Call(savvy_HFile_decode_stream__impl, fpath, frames, dtype))
}

HFile$metadata <- function(fpath, metadata_type) {
  metadata_type <- .savvy_extract_ptr(metadata_type, "HMetadataType")
.Call(savvy_HFile_metadata__impl, fpath, metadata_type)
}

HFile$params <- function(fpath) {
.Call(savvy_HFile_params__impl, fpath)
}

HFile$verify <- function(fpath) {
.Call(savvy_HFile_verify__impl, fpath)
}


### wrapper functions for HInterpolationType

HInterpolationType_print <- function(self) {
  function() {
  invisible(.Call(savvy_HInterpolationType_print__impl, self))
  }
}

HInterpolationType_eq <- function(self) {
  function(other) {
    other <- .savvy_extract_ptr(other, "HInterpolationType")
.Call(savvy_HInterpolationType_eq__impl, self, other)
  }
}

HInterpolationType_ne <- function(self) {
  function(other) {
    other <- .savvy_extract_ptr(other, "HInterpolationType")
.Call(savvy_HInterpolationType_ne__impl, self, other)
  }
}

.savvy_wrap_HInterpolationType <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr
    e$print <- HInterpolationType_print(ptr)
  e$eq <- HInterpolationType_eq(ptr)
  e$ne <- HInterpolationType_ne(ptr)
  
  class(e) <- "HInterpolationType"
  e
}


#' HInterpolationType
#' A interpolation type representation.
#'
#' Supports `Cubic`, `Linear`, `Quadratic` and `Nearest` types.
#'
#' # Methods
#'
HInterpolationType <- new.env(parent = emptyenv())
HInterpolationType$Cubic <- .savvy_wrap_HInterpolationType(0L)
HInterpolationType$Linear <- .savvy_wrap_HInterpolationType(1L)
HInterpolationType$Quadratic <- .savvy_wrap_HInterpolationType(2L)
HInterpolationType$Nearest <- .savvy_wrap_HInterpolationType(3L)

#' @export
print.HInterpolationType <- function(x, ...) {
  idx <- x$.ptr + 1L
  label <- c("Cubic", "Linear", "Quadratic", "Nearest")[idx]
  if (is.na(label)) {
    stop("Unexpected value for HInterpolationType", call. = TRUE)
  }
  cat("HInterpolationType::", label, sep = "")
}


### associated functions for HInterpolationType



### wrapper functions for HMetadataType

HMetadataType_print <- function(self) {
  function() {
  invisible(.Call(savvy_HMetadataType_print__impl, self))
  }
}

HMetadataType_eq <- function(self) {
  function(other) {
    other <- .savvy_extract_ptr(other, "HMetadataType")
.Call(savvy_HMetadataType_eq__impl, self, other)
  }
}

HMetadataType_ne <- function(self) {
  function(other) {
    other <- .savvy_extract_ptr(other, "HMetadataType")
.Call(savvy_HMetadataType_ne__impl, self, other)
  }
}

.savvy_wrap_HMetadataType <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr
    e$print <- HMetadataType_print(ptr)
  e$eq <- HMetadataType_eq(ptr)
  e$ne <- HMetadataType_ne(ptr)
  
  class(e) <- "HMetadataType"
  e
}


#' HMetadataType
#' A metadata type representation.
#'
#' Supports `All`, `Text` and `Visual` types.
#'
#' # Methods
#'
HMetadataType <- new.env(parent = emptyenv())
HMetadataType$All <- .savvy_wrap_HMetadataType(0L)
HMetadataType$Text <- .savvy_wrap_HMetadataType(1L)
HMetadataType$Visual <- .savvy_wrap_HMetadataType(2L)

#' @export
print.HMetadataType <- function(x, ...) {
  idx <- x$.ptr + 1L
  label <- c("All", "Text", "Visual")[idx]
  if (is.na(label)) {
    stop("Unexpected value for HMetadataType", call. = TRUE)
  }
  cat("HMetadataType::", label, sep = "")
}


### associated functions for HMetadataType



### wrapper functions for HPolynomialDegree

HPolynomialDegree_print <- function(self) {
  function() {
  invisible(.Call(savvy_HPolynomialDegree_print__impl, self))
  }
}

HPolynomialDegree_eq <- function(self) {
  function(other) {
    other <- .savvy_extract_ptr(other, "HPolynomialDegree")
.Call(savvy_HPolynomialDegree_eq__impl, self, other)
  }
}

HPolynomialDegree_ne <- function(self) {
  function(other) {
    other <- .savvy_extract_ptr(other, "HPolynomialDegree")
.Call(savvy_HPolynomialDegree_ne__impl, self, other)
  }
}

.savvy_wrap_HPolynomialDegree <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr
    e$print <- HPolynomialDegree_print(ptr)
  e$eq <- HPolynomialDegree_eq(ptr)
  e$ne <- HPolynomialDegree_ne(ptr)
  
  class(e) <- "HPolynomialDegree"
  e
}


#' HPolynomialDegree
#' Degree of the polynomial used for interpolation. A higher degree gives a higher quality result, while taking longer to compute.
#'
#' - `Septic`
#'
#' Septic polynomial, fitted using 8 sample points.
#'
#' - `Quintic`.
#'
#' Quintic polynomial, fitted using 6 sample points.
#'
#' - `Cubic`.
#'
#' Cubic polynomial, fitted using 4 sample points.
#'
#' - `Linear`.
#'
#' Linear polynomial, fitted using 2 sample points.
#'
#' - `Nearest`.
#'
#' Nearest, uses the nearest sample point without any fitting.
#'
#' # Methods
#'
HPolynomialDegree <- new.env(parent = emptyenv())
HPolynomialDegree$Septic <- .savvy_wrap_HPolynomialDegree(0L)
HPolynomialDegree$Quintic <- .savvy_wrap_HPolynomialDegree(1L)
HPolynomialDegree$Cubic <- .savvy_wrap_HPolynomialDegree(2L)
HPolynomialDegree$Linear <- .savvy_wrap_HPolynomialDegree(3L)
HPolynomialDegree$Nearest <- .savvy_wrap_HPolynomialDegree(4L)

#' @export
print.HPolynomialDegree <- function(x, ...) {
  idx <- x$.ptr + 1L
  label <- c("Septic", "Quintic", "Cubic", "Linear", "Nearest")[idx]
  if (is.na(label)) {
    stop("Unexpected value for HPolynomialDegree", call. = TRUE)
  }
  cat("HPolynomialDegree::", label, sep = "")
}


### associated functions for HPolynomialDegree



### wrapper functions for HRealFftPlanner

HRealFftPlanner_rfft <- function(self) {
  function(harray) {
    harray <- .savvy_extract_ptr(harray, "HArray")
invisible(.Call(savvy_HRealFftPlanner_rfft__impl, self, harray))
  }
}

HRealFftPlanner_irfft <- function(self) {
  function(harray, length) {
    harray <- .savvy_extract_ptr(harray, "HArray")
invisible(.Call(savvy_HRealFftPlanner_irfft__impl, self, harray, length))
  }
}

HRealFftPlanner_dtype <- function(self) {
  function() {
    .savvy_wrap_HDataType(.Call(savvy_HRealFftPlanner_dtype__impl, self))
  }
}

HRealFftPlanner_print <- function(self) {
  function() {
  invisible(.Call(savvy_HRealFftPlanner_print__impl, self))
  }
}

.savvy_wrap_HRealFftPlanner <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr
    e$rfft <- HRealFftPlanner_rfft(ptr)
  e$irfft <- HRealFftPlanner_irfft(ptr)
  e$dtype <- HRealFftPlanner_dtype(ptr)
  e$print <- HRealFftPlanner_print(ptr)
  
  class(e) <- "HRealFftPlanner"
  e
}


#' HRealFftPlanner
#' A planner is used to create FFTs. It caches results internally, so when making more than one FFT it is advisable to reuse the same planner.
#'
#' This planner is used to calculate FFTs of real valued inputs and its inverse operation.
#'
#' # Methods
#'
HRealFftPlanner <- new.env(parent = emptyenv())

### associated functions for HRealFftPlanner

HRealFftPlanner$new <- function(dtype) {
  dtype <- .savvy_extract_ptr(dtype, "HDataType")
  .savvy_wrap_HRealFftPlanner(.Call(savvy_HRealFftPlanner_new__impl, dtype))
}


### wrapper functions for HResampler

HResampler_process <- function(self) {
  function(harray) {
    harray <- .savvy_extract_ptr(harray, "HArray")
invisible(.Call(savvy_HResampler_process__impl, self, harray))
  }
}

HResampler_set_resample_ratio <- function(self) {
  function(new_ratio, ramp) {
  invisible(.Call(savvy_HResampler_set_resample_ratio__impl, self, new_ratio, ramp))
  }
}

HResampler_set_resample_ratio_relative <- function(self) {
  function(rel_ratio, ramp) {
  invisible(.Call(savvy_HResampler_set_resample_ratio_relative__impl, self, rel_ratio, ramp))
  }
}

HResampler_reset <- function(self) {
  function() {
  invisible(.Call(savvy_HResampler_reset__impl, self))
  }
}

HResampler_res_type <- function(self) {
  function() {
    .savvy_wrap_HResamplerType(.Call(savvy_HResampler_res_type__impl, self))
  }
}

HResampler_dtype <- function(self) {
  function() {
    .savvy_wrap_HDataType(.Call(savvy_HResampler_dtype__impl, self))
  }
}

HResampler_print <- function(self) {
  function() {
  invisible(.Call(savvy_HResampler_print__impl, self))
  }
}

.savvy_wrap_HResampler <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr
    e$process <- HResampler_process(ptr)
  e$set_resample_ratio <- HResampler_set_resample_ratio(ptr)
  e$set_resample_ratio_relative <- HResampler_set_resample_ratio_relative(ptr)
  e$reset <- HResampler_reset(ptr)
  e$res_type <- HResampler_res_type(ptr)
  e$dtype <- HResampler_dtype(ptr)
  e$print <- HResampler_print(ptr)
  
  class(e) <- "HResampler"
  e
}


#' HResampler
#' A resampler.
#'
#' #### Asynchronous Resamplers
#'
#' The resampling is based on band-limited interpolation using sinc interpolation filters. The sinc interpolation upsamples by an adjustable factor,
#' and then the new sample points are calculated by interpolating between these points.
#'
#' The resampling ratio can be updated at any time.
#'
#' - `SincFixedIn`
#'
#' - `SincFixedOut`
#'
#' - `FastFixedIn`
#'
#' - `FastFixedOut`
#'
#' #### Synchronous Resamplers
#'
#' Is implemented via FFT. The data is FFTed, the spectrum modified, and then inverse FFTed to get the resampled data.
#'
#' This type of resampler is considerably faster but doesn’t support changing the resampling ratio.
#'
#' - `FftFixedIn`
#'
#' - `FftFixedInOut`
#'
#' - `FftFixedOut`
#'
#' # Methods
#'
HResampler <- new.env(parent = emptyenv())

### associated functions for HResampler

HResampler$new_fft <- function(sr_in, sr_out, chunk_size, sub_chunks, nchannels, res_type, dtype) {
  res_type <- .savvy_extract_ptr(res_type, "HResamplerType")
  dtype <- .savvy_extract_ptr(dtype, "HDataType")
  .savvy_wrap_HResampler(.Call(savvy_HResampler_new_fft__impl, sr_in, sr_out, chunk_size, sub_chunks, nchannels, res_type, dtype))
}

HResampler$new_sinc <- function(resample_ratio, max_resample_ratio_relative, parameters, chunk_size, nchannels, res_type, dtype) {
  parameters <- .savvy_extract_ptr(parameters, "HSincInterpolationParameters")
  res_type <- .savvy_extract_ptr(res_type, "HResamplerType")
  dtype <- .savvy_extract_ptr(dtype, "HDataType")
  .savvy_wrap_HResampler(.Call(savvy_HResampler_new_sinc__impl, resample_ratio, max_resample_ratio_relative, parameters, chunk_size, nchannels, res_type, dtype))
}

HResampler$new_fast <- function(resample_ratio, max_resample_ratio_relative, pol_deg, chunk_size, nchannels, res_type, dtype) {
  pol_deg <- .savvy_extract_ptr(pol_deg, "HPolynomialDegree")
  res_type <- .savvy_extract_ptr(res_type, "HResamplerType")
  dtype <- .savvy_extract_ptr(dtype, "HDataType")
  .savvy_wrap_HResampler(.Call(savvy_HResampler_new_fast__impl, resample_ratio, max_resample_ratio_relative, pol_deg, chunk_size, nchannels, res_type, dtype))
}


### wrapper functions for HResamplerType

HResamplerType_print <- function(self) {
  function() {
  invisible(.Call(savvy_HResamplerType_print__impl, self))
  }
}

HResamplerType_eq <- function(self) {
  function(other) {
    other <- .savvy_extract_ptr(other, "HResamplerType")
.Call(savvy_HResamplerType_eq__impl, self, other)
  }
}

HResamplerType_ne <- function(self) {
  function(other) {
    other <- .savvy_extract_ptr(other, "HResamplerType")
.Call(savvy_HResamplerType_ne__impl, self, other)
  }
}

.savvy_wrap_HResamplerType <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr
    e$print <- HResamplerType_print(ptr)
  e$eq <- HResamplerType_eq(ptr)
  e$ne <- HResamplerType_ne(ptr)
  
  class(e) <- "HResamplerType"
  e
}


#' HResamplerType
#' A resampler type representation.
#'
#' Supports `FftFixedIn`, `FftFixedInOut`, `FftFixedOut`, `SincFixedIn`, `SincFixedOut`,
#' `FastFixedIn` and `FastFixedOut` types.
#'
#' # Methods
#'
HResamplerType <- new.env(parent = emptyenv())
HResamplerType$FftFixedIn <- .savvy_wrap_HResamplerType(0L)
HResamplerType$FftFixedInOut <- .savvy_wrap_HResamplerType(1L)
HResamplerType$FftFixedOut <- .savvy_wrap_HResamplerType(2L)
HResamplerType$SincFixedIn <- .savvy_wrap_HResamplerType(3L)
HResamplerType$SincFixedOut <- .savvy_wrap_HResamplerType(4L)
HResamplerType$FastFixedIn <- .savvy_wrap_HResamplerType(5L)
HResamplerType$FastFixedOut <- .savvy_wrap_HResamplerType(6L)

#' @export
print.HResamplerType <- function(x, ...) {
  idx <- x$.ptr + 1L
  label <- c("FftFixedIn", "FftFixedInOut", "FftFixedOut", "SincFixedIn", "SincFixedOut", "FastFixedIn", "FastFixedOut")[idx]
  if (is.na(label)) {
    stop("Unexpected value for HResamplerType", call. = TRUE)
  }
  cat("HResamplerType::", label, sep = "")
}


### associated functions for HResamplerType



### wrapper functions for HSincInterpolationParameters

HSincInterpolationParameters_print <- function(self) {
  function() {
  invisible(.Call(savvy_HSincInterpolationParameters_print__impl, self))
  }
}

.savvy_wrap_HSincInterpolationParameters <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr
    e$print <- HSincInterpolationParameters_print(ptr)
  
  class(e) <- "HSincInterpolationParameters"
  e
}


#' HSincInterpolationParameters
#' Parameters to be used for sinc interpolation.
#'
#' # Methods
#'
HSincInterpolationParameters <- new.env(parent = emptyenv())

### associated functions for HSincInterpolationParameters

HSincInterpolationParameters$new <- function(sinc_len, f_cutoff, oversampling_factor, interpolation, window) {
  interpolation <- .savvy_extract_ptr(interpolation, "HInterpolationType")
  window <- .savvy_extract_ptr(window, "HWindowType")
  .savvy_wrap_HSincInterpolationParameters(.Call(savvy_HSincInterpolationParameters_new__impl, sinc_len, f_cutoff, oversampling_factor, interpolation, window))
}


### wrapper functions for HWindow


.savvy_wrap_HWindow <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr
  
  
  class(e) <- "HWindow"
  e
}



HWindow <- new.env(parent = emptyenv())

### associated functions for HWindow

HWindow$barthann <- function(npoints, sym, dtype) {
  dtype <- .savvy_extract_ptr(dtype, "HDataType")
  .savvy_wrap_HArray(.Call(savvy_HWindow_barthann__impl, npoints, sym, dtype))
}

HWindow$bartlett <- function(npoints, sym, dtype) {
  dtype <- .savvy_extract_ptr(dtype, "HDataType")
  .savvy_wrap_HArray(.Call(savvy_HWindow_bartlett__impl, npoints, sym, dtype))
}

HWindow$blackman <- function(npoints, sym, dtype) {
  dtype <- .savvy_extract_ptr(dtype, "HDataType")
  .savvy_wrap_HArray(.Call(savvy_HWindow_blackman__impl, npoints, sym, dtype))
}

HWindow$blackmanharris <- function(npoints, sym, dtype) {
  dtype <- .savvy_extract_ptr(dtype, "HDataType")
  .savvy_wrap_HArray(.Call(savvy_HWindow_blackmanharris__impl, npoints, sym, dtype))
}

HWindow$bohman <- function(npoints, sym, dtype) {
  dtype <- .savvy_extract_ptr(dtype, "HDataType")
  .savvy_wrap_HArray(.Call(savvy_HWindow_bohman__impl, npoints, sym, dtype))
}

HWindow$boxcar <- function(npoints, dtype) {
  dtype <- .savvy_extract_ptr(dtype, "HDataType")
  .savvy_wrap_HArray(.Call(savvy_HWindow_boxcar__impl, npoints, dtype))
}

HWindow$cosine <- function(npoints, sym, dtype) {
  dtype <- .savvy_extract_ptr(dtype, "HDataType")
  .savvy_wrap_HArray(.Call(savvy_HWindow_cosine__impl, npoints, sym, dtype))
}

HWindow$hann <- function(npoints, sym, dtype) {
  dtype <- .savvy_extract_ptr(dtype, "HDataType")
  .savvy_wrap_HArray(.Call(savvy_HWindow_hann__impl, npoints, sym, dtype))
}


### wrapper functions for HWindowType

HWindowType_print <- function(self) {
  function() {
  invisible(.Call(savvy_HWindowType_print__impl, self))
  }
}

HWindowType_eq <- function(self) {
  function(other) {
    other <- .savvy_extract_ptr(other, "HWindowType")
.Call(savvy_HWindowType_eq__impl, self, other)
  }
}

HWindowType_ne <- function(self) {
  function(other) {
    other <- .savvy_extract_ptr(other, "HWindowType")
.Call(savvy_HWindowType_ne__impl, self, other)
  }
}

.savvy_wrap_HWindowType <- function(ptr) {
  e <- new.env(parent = emptyenv())
  e$.ptr <- ptr
    e$print <- HWindowType_print(ptr)
  e$eq <- HWindowType_eq(ptr)
  e$ne <- HWindowType_ne(ptr)
  
  class(e) <- "HWindowType"
  e
}


#' HWindowType
#' A window type representation.
#'
#' Supports `Blackman`, `Blackman2`, `BlackmanHarris`, `BlackmanHarris2`, `Hann` and `Hann2` types.
#'
#' # Methods
#'
HWindowType <- new.env(parent = emptyenv())
HWindowType$Blackman <- .savvy_wrap_HWindowType(0L)
HWindowType$Blackman2 <- .savvy_wrap_HWindowType(1L)
HWindowType$BlackmanHarris <- .savvy_wrap_HWindowType(2L)
HWindowType$BlackmanHarris2 <- .savvy_wrap_HWindowType(3L)
HWindowType$Hann <- .savvy_wrap_HWindowType(4L)
HWindowType$Hann2 <- .savvy_wrap_HWindowType(5L)

#' @export
print.HWindowType <- function(x, ...) {
  idx <- x$.ptr + 1L
  label <- c("Blackman", "Blackman2", "BlackmanHarris", "BlackmanHarris2", "Hann", "Hann2")[idx]
  if (is.na(label)) {
    stop("Unexpected value for HWindowType", call. = TRUE)
  }
  cat("HWindowType::", label, sep = "")
}


### associated functions for HWindowType



