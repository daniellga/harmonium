[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "docs/harray.html",
    "href": "docs/harray.html",
    "title": "HArray",
    "section": "",
    "text": "An array representation."
  },
  {
    "objectID": "docs/harray.html#new_from_values",
    "href": "docs/harray.html#new_from_values",
    "title": "HArray",
    "section": "new_from_values",
    "text": "new_from_values\nnew_from_array(arr: array, dtype: HDataType) -&gt; HArray  source \n\nCreates a new HArray from an R array.\n\n\nArguments\n\narr\nA double or complex array.\ndtype\nAn HDataType to indicate which type of HArray to be created.\nFor float dtypes, the atomic vector must be a double. For complex dtypes, a complex atomic vector.\n\n\n\nReturns\nAn HArray.\n\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nHArray$new_from_values(arr, dtype)"
  },
  {
    "objectID": "docs/harray.html#len",
    "href": "docs/harray.html#len",
    "title": "HArray",
    "section": "len",
    "text": "len\nlen() -&gt; integer  source \n\nReturns the number of elements of this Harray.\n\n\nReturns\nAn integer.\n\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray = HArray$new_from_values(arr, dtype)\nharray$len()"
  },
  {
    "objectID": "docs/harray.html#shape",
    "href": "docs/harray.html#shape",
    "title": "HArray",
    "section": "shape",
    "text": "shape\nshape() -&gt; integers  source \n\nReturns the shape of this HArray.\n\n\nReturns\nA vector of integers.\n\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray = HArray$new_from_values(arr, dtype)\nharray$shape()"
  },
  {
    "objectID": "docs/harray.html#ndim",
    "href": "docs/harray.html#ndim",
    "title": "HArray",
    "section": "ndim",
    "text": "ndim\nndim() -&gt; integer  source \n\nReturns the number of dimensions of this HArray.\n\n\nReturns\nAn integer.\n\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray = HArray$new_from_values(arr, dtype)\nharray$ndim()"
  },
  {
    "objectID": "docs/harray.html#print",
    "href": "docs/harray.html#print",
    "title": "HArray",
    "section": "print",
    "text": "print\nprint()  source \n\nPrints the HArray.\nDifferently from R’s normal behaviour, print doesn’t return the value invisibly.\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray = HArray$new_from_values(arr, dtype)\nharray$print()\n\n# or similarly:\nprint(harray)"
  },
  {
    "objectID": "docs/harray.html#eq",
    "href": "docs/harray.html#eq",
    "title": "HArray",
    "section": "eq",
    "text": "eq\neq(other: HArray) -&gt; bool  source \n\nEquality with another HArray.\nThe comparison only checks if the dtype and the values are the same. To compare if the underlying data is the same in memory, check mem_adress.\n\n\nArguments\n\nother\nAn HArray.\n\n\n\n\nReturns\nA bool.\n\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray1 = HArray$new_from_values(arr, dtype)\n\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray2 = HArray$new_from_values(arr, dtype)\n\nharray1$eq(harray2) # TRUE\n\n# or similarly:\nharray1 == harray2"
  },
  {
    "objectID": "docs/harray.html#ne",
    "href": "docs/harray.html#ne",
    "title": "HArray",
    "section": "ne",
    "text": "ne\nne(other: HArray) -&gt; bool  source \n\nDifference with another HArray.\nThe comparison only checks if the dtype and the values are the same. To compare if the underlying data is the same in memory, check mem_adress.\n\nArguments\n\nother\nAn HArray.\n\n\n\nReturns\nA bool.\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray1 = HArray$new_from_values(arr, dtype)\n\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray2 = HArray$new_from_values(arr, dtype)\n\nharray1$ne(harray2) # FALSE\n\n# or similarly:\nharray1 != harray2"
  },
  {
    "objectID": "docs/harray.html#clone",
    "href": "docs/harray.html#clone",
    "title": "HArray",
    "section": "clone",
    "text": "clone\nclone() -&gt; HArray  source \n\nCreates a new HArray, with the underlying data pointing to the same place in memory.\n\nReturns\nAn HArray.\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray1 = HArray$new_from_values(arr, dtype)\nharray2 = harray1$clone()\nharray1 == harray2 # TRUE"
  },
  {
    "objectID": "docs/harray.html#collect",
    "href": "docs/harray.html#collect",
    "title": "HArray",
    "section": "collect",
    "text": "collect\ncollect() -&gt; array  source \n\nCreates an R array from an HArray. The type of the array created (double or complex) will depend on the HArray’s dtype.\n\nReturns\nAn array of type double or complex.\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray = HArray$new_from_values(arr, dtype)\nharray$collect()"
  },
  {
    "objectID": "docs/harray.html#dtype",
    "href": "docs/harray.html#dtype",
    "title": "HArray",
    "section": "dtype",
    "text": "dtype\ndtype() -&gt; HDataType  source \n\nGets the HArray’s dtype as an HDataType.\n\nReturns\nAn HDataType.\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray = HArray$new_from_values(arr, dtype)\nharray$dtype()"
  },
  {
    "objectID": "docs/harray.html#is_shared",
    "href": "docs/harray.html#is_shared",
    "title": "HArray",
    "section": "is_shared",
    "text": "is_shared\nis_shared() -&gt; bool  source \n\nChecks if the object is shared.\nSince HArray has a COW (clone-on-write) behaviour, this function is useful to check if a new object will be created or if the change will be done in-place.\n\n\nReturns\nA bool.\n\n\n\nExamples\narr = array(c(1,2,3,4,5,6,7,8,9,10,11,12), c(3,4))\ndtype = HDataType$float32\nharray1 = HArray$new_from_values(arr, dtype)\nharray1$is_shared() # FALSE.\n\nharray2 = harray1$clone()\nharray$is_shared() # TRUE, HArray object shared with harray2."
  },
  {
    "objectID": "docs/haudiosink.html",
    "href": "docs/haudiosink.html",
    "title": "HAudioSink",
    "section": "",
    "text": "Handle to a device that outputs sounds."
  },
  {
    "objectID": "docs/haudiosink.html#new",
    "href": "docs/haudiosink.html#new",
    "title": "HAudioSink",
    "section": "new",
    "text": "new\nnew() -&gt; HAudioSink  source \n\nCreates a new HAudioSink instance.\nThe sink is set on “play” mode from the start.\n\n\nReturns\nAn HAudioSink.\n\n\n\nExamples\nhaudiosink = HAudioSink$new()"
  },
  {
    "objectID": "docs/haudiosink.html#append_from_haudio",
    "href": "docs/haudiosink.html#append_from_haudio",
    "title": "HAudioSink",
    "section": "append_from_haudio",
    "text": "append_from_haudio\nappend_from_haudio(haudio: HAudio)  source \n\nAppends a sound to the queue of sounds to play.\n\n\nArguments\n\nhaudio\nAn HAudio.\n\n\n\n\nExamples\nhaudiosink = HAudioSink$new()\nhaudio = HAudio$new_from_file(fpath = \"../../../testfiles/gs-16b-2c-44100hz.wav\", dtype = HDataType$float32)\nhaudiosink$append_from_haudio(haudio)"
  },
  {
    "objectID": "docs/haudiosink.html#append_from_file",
    "href": "docs/haudiosink.html#append_from_file",
    "title": "HAudioSink",
    "section": "append_from_file",
    "text": "append_from_file\nappend_from_file(fpath: string)  source \n\nAppends a sound to the queue of sounds to play.\n\n\nArguments\n\nfpath\nThe file path as a string.\n\n\n\n\nExamples\nhaudiosink = HAudioSink$new()\nhaudiosink$append_from_file(fpath = \"../../../testfiles/gs-16b-2c-44100hz.wav\")"
  },
  {
    "objectID": "docs/haudiosink.html#play",
    "href": "docs/haudiosink.html#play",
    "title": "HAudioSink",
    "section": "play",
    "text": "play\nplay()  source \n\nResumes playback of a paused sink.\nNo effect if not paused.\n\n\nExamples\nhaudiosink = HAudioSink$new()\nhaudiosink$append_from_file(fpath = \"../../../testfiles/gs-16b-2c-44100hz.wav\")\nhaudiosink$pause()\nhaudiosink$is_paused() # TRUE\nhaudiosink$play()\nhaudiosink$is_paused() # FALSE"
  },
  {
    "objectID": "docs/haudiosink.html#stop",
    "href": "docs/haudiosink.html#stop",
    "title": "HAudioSink",
    "section": "stop",
    "text": "stop\nstop()  source \n\nStops the sink by emptying the queue.\nThe sink will keep its previous state (play or pause).\n\n\nExamples\nhaudiosink = HAudioSink$new()\nhaudiosink$append_from_file(fpath = \"../../../testfiles/gs-16b-2c-44100hz.wav\")\nhaudiosink$append_from_file(fpath = \"../../../testfiles/gs-16b-2c-44100hz.wav\")\nhaudiosink$len() == 2 # TRUE\nhaudiosink$stop()\nhaudiosink$len() == 0 # TRUE\nhaudiosink$is_paused() # FALSE"
  },
  {
    "objectID": "docs/haudiosink.html#pause",
    "href": "docs/haudiosink.html#pause",
    "title": "HAudioSink",
    "section": "pause",
    "text": "pause\npause()  source \n\nPauses playback of this sink.\nNo effect if already paused.\nA paused sink can be resumed with play().\n\n\nExamples\nhaudiosink = HAudioSink$new()\nhaudiosink$append_from_file(fpath = \"../../../testfiles/gs-16b-2c-44100hz.wav\")\nhaudiosink$is_paused() # FALSE\nhaudiosink$pause()\nhaudiosink$is_paused() # TRUE"
  },
  {
    "objectID": "docs/haudiosink.html#is_paused",
    "href": "docs/haudiosink.html#is_paused",
    "title": "HAudioSink",
    "section": "is_paused",
    "text": "is_paused\nis_paused() -&gt; bool  source \n\nGets if a sink is paused.\nSinks can be paused and resumed using pause() and play(). This returns true if the sink is paused.\n\n\nReturns\nA bool.\n\n\n\nExamples\nhaudiosink = HAudioSink$new()\nhaudiosink$append_from_file(fpath = \"../../../testfiles/gs-16b-2c-44100hz.wav\")\nhaudiosink$is_paused() # FALSE\nhaudiosink$pause()\nhaudiosink$is_paused() # TRUE"
  },
  {
    "objectID": "docs/haudiosink.html#volume",
    "href": "docs/haudiosink.html#volume",
    "title": "HAudioSink",
    "section": "volume",
    "text": "volume\nvolume() -&gt; double  source \n\nGets the volume of the sound.\nThe value 1.0 is the “normal” volume (unfiltered input). Any value other than 1.0 will multiply each sample by this value.\n\n\nReturns\nA double.\n\n\n\nExamples\nhaudiosink = HAudioSink$new()\nhaudiosink$append_from_file(fpath = \"../../../testfiles/gs-16b-2c-44100hz.wav\")\nhaudiosink$volume()"
  },
  {
    "objectID": "docs/haudiosink.html#set_volume",
    "href": "docs/haudiosink.html#set_volume",
    "title": "HAudioSink",
    "section": "set_volume",
    "text": "set_volume\nset_volume(value: double)  source \n\nChanges the volume of the sound.\nThe value 1.0 is the “normal” volume (unfiltered input). Any value other than 1.0 will multiply each sample by this value.\n\n\nArguments\n\nvalue\nA double.\n\n\n\n\nExamples\nhaudiosink = HAudioSink$new()\nhaudiosink$append_from_file(fpath = \"../../../testfiles/gs-16b-2c-44100hz.wav\")\nhaudiosink$set_volume(2)\nhaudiosink$volume() == 2 # TRUE"
  },
  {
    "objectID": "docs/haudiosink.html#speed",
    "href": "docs/haudiosink.html#speed",
    "title": "HAudioSink",
    "section": "speed",
    "text": "speed\nspeed() -&gt; double  source \n\nGets the speed of the sound.\nThe value 1.0 is the “normal” speed (unfiltered input). Any value other than 1.0 will change the play speed of the sound.\n\n\nReturns\nA double.\n\n\n\nExamples\nhaudiosink = HAudioSink$new()\nhaudiosink$append_from_file(fpath = \"../../../testfiles/gs-16b-2c-44100hz.wav\")\nhaudiosink$speed()"
  },
  {
    "objectID": "docs/haudiosink.html#set_speed",
    "href": "docs/haudiosink.html#set_speed",
    "title": "HAudioSink",
    "section": "set_speed",
    "text": "set_speed\nset_speed(value: double)  source \n\nChanges the speed of the sound.\nThe value 1.0 is the “normal” speed (unfiltered input). Any value other than 1.0 will change the play speed of the sound.\n\n\nArguments\n\nvalue\nA double.\n\n\n\n\nExamples\nhaudiosink = HAudioSink$new()\nhaudiosink$append_from_file(fpath = \"../../../testfiles/gs-16b-2c-44100hz.wav\")\nhaudiosink$set_speed(2)\nhaudiosink$speed() == 2 # TRUE"
  },
  {
    "objectID": "docs/haudiosink.html#sleep_until_end",
    "href": "docs/haudiosink.html#sleep_until_end",
    "title": "HAudioSink",
    "section": "sleep_until_end",
    "text": "sleep_until_end\nsleep_until_end()  source \n\nSleeps the current thread until the sound ends.\n\n\nExamples\nhaudiosink = HAudioSink$new()\nhaudiosink$append_from_file(fpath = \"../../../testfiles/gs-16b-2c-44100hz.wav\")\nhaudiosink$sleep_until_end()"
  },
  {
    "objectID": "docs/haudiosink.html#len",
    "href": "docs/haudiosink.html#len",
    "title": "HAudioSink",
    "section": "len",
    "text": "len\nlen() -&gt; integer  source \n\nReturns the number of sounds currently in the queue.\n\n\nReturns\nAn integer.\n\n\n\nExamples\nhaudiosink = HAudioSink$new()\nhaudiosink$len() == 0 # TRUE\nhaudiosink$append_from_file(fpath = \"../../../testfiles/gs-16b-2c-44100hz.wav\")\nhaudiosink$append_from_file(fpath = \"../../../testfiles/gs-16b-2c-44100hz.wav\")\nhaudiosink$len() == 2 # TRUE"
  },
  {
    "objectID": "docs/haudiosink.html#is_empty",
    "href": "docs/haudiosink.html#is_empty",
    "title": "HAudioSink",
    "section": "is_empty",
    "text": "is_empty\nis_empty() -&gt; bool  source \n\nReturns true if this sink has no more sounds to play.\n\n\nReturns\nA bool.\n\n\n\nExamples\nhaudiosink = HAudioSink$new()\nhaudiosink$is_empty() # TRUE"
  },
  {
    "objectID": "docs/haudiosink.html#clear",
    "href": "docs/haudiosink.html#clear",
    "title": "HAudioSink",
    "section": "clear",
    "text": "clear\nclear()  source \n\nRemoves all currently loaded Sources from the Sink and pauses it.\n\n\nExamples\nhaudiosink = HAudioSink$new()\nhaudiosink$append_from_file(fpath = \"../../../testfiles/gs-16b-2c-44100hz.wav\")\nhaudiosink$clear()\nhaudiosink$is_empty() # TRUE\nhaudiosink$is_paused() # TRUE"
  },
  {
    "objectID": "docs/haudiosink.html#skip_one",
    "href": "docs/haudiosink.html#skip_one",
    "title": "HAudioSink",
    "section": "skip_one",
    "text": "skip_one\nskip_one()  source \n\nSkips to the next Source in the Sink.\nIf there are more Sources appended to the Sink at the time, it will play the next one. Otherwise, the Sink will finish as if it had finished playing a Source all the way through.\n\n\nExamples\nhaudiosink = HAudioSink$new()\nhaudiosink$append_from_file(fpath = \"../../../testfiles/gs-16b-2c-44100hz.wav\")\nhaudiosink$append_from_file(fpath = \"../../../testfiles/gs-16b-2c-44100hz.wav\")\nhaudiosink$len() == 2 # TRUE\nhaudiosink$skip_one()\nhaudiosink$len() == 1 # TRUE"
  },
  {
    "objectID": "docs/haudiosink.html#audio_output_devices",
    "href": "docs/haudiosink.html#audio_output_devices",
    "title": "HAudioSink",
    "section": "audio_output_devices",
    "text": "audio_output_devices\naudio_output_devices() -&gt; atomicvector  source \n\nProvides a list of available audio output devices.\n\n\nReturns\nA character atomic vector.\n\n\n\nExamples\nHAudioSink$audio_output_devices()"
  },
  {
    "objectID": "docs/haudiosink.html#audio_default_device",
    "href": "docs/haudiosink.html#audio_default_device",
    "title": "HAudioSink",
    "section": "audio_default_device",
    "text": "audio_default_device\naudio_default_device() -&gt; string  source \n\nInforms the default audio output device.\n\n\nReturns\nA string.\n\n\n\nExamples\nHAudioSink$audio_default_device()"
  },
  {
    "objectID": "docs/haudiosink.html#audio_supported_configs",
    "href": "docs/haudiosink.html#audio_supported_configs",
    "title": "HAudioSink",
    "section": "audio_supported_configs",
    "text": "audio_supported_configs\naudio_supported_configs() -&gt; atomicvector  source \n\nProvides the supported configurations for the default audio output device.\nThe following informations are given:\n\n\nNumber of channels.\n\nMinimum and maximum value for the sampling rate.\n\nMinimum and maximum value for the buffer size.\n\nType of data expected by the device.\n\n\n\nReturns\nA character atomic vector.\n\n\n\nExamples\nHAudioSink$audio_supported_configs()"
  },
  {
    "objectID": "docs/hdatatype.html",
    "href": "docs/hdatatype.html",
    "title": "HDataType",
    "section": "",
    "text": "A type representation.\nSupports Float32, Float64, Complex32 and Complex64 types."
  },
  {
    "objectID": "docs/hdatatype.html#float32",
    "href": "docs/hdatatype.html#float32",
    "title": "HDataType",
    "section": "float32",
    "text": "float32\nfloat32 -&gt; HDataType  source \n\nCreates a Float32 HDataType.\n\n\nReturns\nAn HDataType.\n\n\n\nExamples\ndtype = HDataType$float32"
  },
  {
    "objectID": "docs/hdatatype.html#float64",
    "href": "docs/hdatatype.html#float64",
    "title": "HDataType",
    "section": "float64",
    "text": "float64\nfloat64 -&gt; HDataType  source \n\nCreates a Float64 HDataType.\n\n\nReturns\nAn HDataType.\n\n\n\nExamples\ndtype = HDataType$float64"
  },
  {
    "objectID": "docs/hdatatype.html#complex32",
    "href": "docs/hdatatype.html#complex32",
    "title": "HDataType",
    "section": "complex32",
    "text": "complex32\ncomplex32 -&gt; HDataType  source \n\nCreates a Complex32 HDataType.\n\n\nReturns\nAn HDataType.\n\n\n\nExamples\ndtype = HDataType$complex32"
  },
  {
    "objectID": "docs/hdatatype.html#complex64",
    "href": "docs/hdatatype.html#complex64",
    "title": "HDataType",
    "section": "complex64",
    "text": "complex64\ncomplex64 -&gt; HDataType  source \n\nCreates a Complex64 HDataType.\n\n\nReturns\nAn HDataType.\n\n\n\nExamples\ndtype = HDataType$complex64"
  },
  {
    "objectID": "docs/hdatatype.html#print",
    "href": "docs/hdatatype.html#print",
    "title": "HDataType",
    "section": "print",
    "text": "print\nprint()  source \n\nPrints the HDataType.\nDifferently from R’s behaviour, print doesn’t return the value invisibly.\n\n\nExamples\ndtype = HDataType$complex64\ndtype$print()\n\n# or similarly:\nprint(dtype)"
  },
  {
    "objectID": "docs/hdatatype.html#eq",
    "href": "docs/hdatatype.html#eq",
    "title": "HDataType",
    "section": "eq",
    "text": "eq\neq(other: HDataType) -&gt; bool  source \n\nEquality with another HDataType.\n\n\nArguments\n\nother\nAn HDataType.\n\n\n\n\nReturns\nA bool.\n\n\nExamples\nhdatatype1 = HDataType$float32\nhdatatype2 = HDataType$float32\nhdatatype1$eq(hdatatype2) # TRUE\n\n# or similarly:\nhdatatype1 == hdatatype2"
  },
  {
    "objectID": "docs/hdatatype.html#ne",
    "href": "docs/hdatatype.html#ne",
    "title": "HDataType",
    "section": "ne",
    "text": "ne\nne(other: HDataType) -&gt; bool  source \n\nDifference with another HDataType.\n\n\nArguments\n\nother\nAn HDataType.\n\n\n\n\nReturns\nA bool.\n\n\n\nExamples\nhdatatype1 = HDataType$float32\nhdatatype2 = HDataType$float64\nhdatatype1$ne(hdatatype2) # TRUE\n\n# or similarly:\nhdatatype1 != hdatatype2"
  },
  {
    "objectID": "docs/hmetadatatype.html",
    "href": "docs/hmetadatatype.html",
    "title": "HMetadataType",
    "section": "",
    "text": "A metadata type representation.\nSupports All, Text and Visual types."
  },
  {
    "objectID": "docs/hmetadatatype.html#all",
    "href": "docs/hmetadatatype.html#all",
    "title": "HMetadataType",
    "section": "all",
    "text": "all\nall -&gt; HMetadataType  source \n\nCreates an All HMetadataType.\n\n\nReturns\nAn HMetadataType.\n\n\nExamples\nHMetadataType$all"
  },
  {
    "objectID": "docs/hmetadatatype.html#text",
    "href": "docs/hmetadatatype.html#text",
    "title": "HMetadataType",
    "section": "text",
    "text": "text\ntext -&gt; HMetadataType  source \n\nCreates a Text HMetadataType.\n\n\nReturns\nAn HMetadataType.\n\n\nExamples\nHMetadataType$text"
  },
  {
    "objectID": "docs/hmetadatatype.html#visual",
    "href": "docs/hmetadatatype.html#visual",
    "title": "HMetadataType",
    "section": "visual",
    "text": "visual\nvisual -&gt; HMetadataType  source \n\nCreates a Visual HMetadataType.\n\n\nReturns\nAn HMetadataType.\n\n\nExamples\nHMetadataType$visual"
  },
  {
    "objectID": "docs/hmetadatatype.html#print",
    "href": "docs/hmetadatatype.html#print",
    "title": "HMetadataType",
    "section": "print",
    "text": "print\nprint()  source \n\nPrints the HMetadataType.\nDifferently from R’s behaviour, print doesn’t return the value invisibly.\n\n\nExamples\nmetadatatype = HMetadataType$complex64\nmetadatatype$print()\n\n# or similarly:\nprint(metadatatype)"
  },
  {
    "objectID": "docs/hmetadatatype.html#eq",
    "href": "docs/hmetadatatype.html#eq",
    "title": "HMetadataType",
    "section": "eq",
    "text": "eq\neq(other: HMetadataType) -&gt; bool  source \n\nEquality with another HMetadataType.\n\nArguments\n\nother\nAn HMetadataType.\n\n\n\n\nReturns\nA bool.\n\n\nExamples\nmetadatatype1 = HMetadataType$all\nmetadatatype2 = HMetadataType$all\nmetadatatype1$eq(metadatatype2) # TRUE\n\n# or similarly:\nmetadatatype1 == metadatatype2"
  },
  {
    "objectID": "docs/hmetadatatype.html#ne",
    "href": "docs/hmetadatatype.html#ne",
    "title": "HMetadataType",
    "section": "ne",
    "text": "ne\nne(other: HMetadataType) -&gt; bool  source \n\nDifference with another HMetadataType.\n\nArguments\n\nother\nAn HMetadataType.\n\n\n\n\nReturns\nA bool.\n\n\nExamples\nmetadatatype1 = HMetadataType$all\nmetadatatype2 = HMetadataType$all\nmetadatatype1$ne(metadatatype2) # FALSE\n\n# or similarly:\nmetadatatype1 != metadatatype2"
  },
  {
    "objectID": "docs/hpolynomialdegree.html",
    "href": "docs/hpolynomialdegree.html",
    "title": "HPolynomialDegree",
    "section": "",
    "text": "Degree of the polynomial used for interpolation. A higher degree gives a higher quality result, while taking longer to compute."
  },
  {
    "objectID": "docs/hpolynomialdegree.html#septic",
    "href": "docs/hpolynomialdegree.html#septic",
    "title": "HPolynomialDegree",
    "section": "Septic",
    "text": "Septic\nseptic -&gt; HPolynomialDegree  source \n\nCreates a Septic HPolynomialDegree.\n\n\nReturns\nAn HPolynomialDegree.\n\n\nExamples\npol_deg = HPolynomialDegree$septic"
  },
  {
    "objectID": "docs/hpolynomialdegree.html#quintic",
    "href": "docs/hpolynomialdegree.html#quintic",
    "title": "HPolynomialDegree",
    "section": "Quintic",
    "text": "Quintic\nquintic -&gt; HPolynomialDegree  source \n\nCreates a Quintic HPolynomialDegree.\n\n\nReturns\nAn HPolynomialDegree.\n\n\nExamples\npol_deg = HPolynomialDegree$quintic"
  },
  {
    "objectID": "docs/hpolynomialdegree.html#cubic",
    "href": "docs/hpolynomialdegree.html#cubic",
    "title": "HPolynomialDegree",
    "section": "Cubic",
    "text": "Cubic\ncubic -&gt; HPolynomialDegree  source \n\nCreates a Cubic HPolynomialDegree.\n\n\nReturns\nAn HPolynomialDegree.\n\n\nExamples\npol_deg = HPolynomialDegree$cubic"
  },
  {
    "objectID": "docs/hpolynomialdegree.html#linear",
    "href": "docs/hpolynomialdegree.html#linear",
    "title": "HPolynomialDegree",
    "section": "Linear",
    "text": "Linear\nlinear -&gt; HPolynomialDegree  source \n\nCreates a Linear HPolynomialDegree.\n\n\nReturns\nAn HPolynomialDegree.\n\n\nExamples\npol_deg = HPolynomialDegree$linear"
  },
  {
    "objectID": "docs/hpolynomialdegree.html#nearest",
    "href": "docs/hpolynomialdegree.html#nearest",
    "title": "HPolynomialDegree",
    "section": "Nearest",
    "text": "Nearest\nnearest -&gt; HPolynomialDegree  source \n\nCreates a Nearest HPolynomialDegree.\n\n\nReturns\nAn HPolynomialDegree.\n\n\nExamples\npol_deg = HPolynomialDegree$nearest"
  },
  {
    "objectID": "docs/hpolynomialdegree.html#print",
    "href": "docs/hpolynomialdegree.html#print",
    "title": "HPolynomialDegree",
    "section": "print",
    "text": "print\nprint()  source \n\nPrints the HPolynomialDegree.\nDifferently from R’s behaviour, print doesn’t return the value invisibly.\n\n\nExamples\npol_deg = HPolynomialDegree$complex64\npol_deg$print()\n\n# or similarly:\nprint(pol_deg)"
  },
  {
    "objectID": "docs/hpolynomialdegree.html#eq",
    "href": "docs/hpolynomialdegree.html#eq",
    "title": "HPolynomialDegree",
    "section": "eq",
    "text": "eq\neq(other: HPolynomialDegree) -&gt; bool  source \n\nEquality with another HPolynomialDegree.\n\nArguments\n\nother\nAn HPolynomialDegree.\n\n\n\n\nReturns\nA bool.\n\n\nExamples\npol_deg1 = HPolynomialDegree$quintic\npol_deg2 = HPolynomialDegree$quintic\npol_deg1$eq(pol_deg2) # TRUE\n\n# or similarly:\npol_deg1 == pol_deg2"
  },
  {
    "objectID": "docs/hpolynomialdegree.html#ne",
    "href": "docs/hpolynomialdegree.html#ne",
    "title": "HPolynomialDegree",
    "section": "ne",
    "text": "ne\nne(other: HPolynomialDegree) -&gt; bool  source \n\nDifference with another HPolynomialDegree.\n\nArguments\n\nother\nAn HPolynomialDegree.\n\n\n\n\nReturns\nA bool.\n\n\nExamples\npol_deg1 = HPolynomialDegree$quintic\npol_deg2 = HPolynomialDegree$nearest\npol_deg1$ne(pol_deg2) # TRUE\n\n# or similarly:\npol_deg1 != pol_deg2"
  },
  {
    "objectID": "docs/hresampler.html",
    "href": "docs/hresampler.html",
    "title": "HResampler",
    "section": "",
    "text": "A resampler."
  },
  {
    "objectID": "docs/hresampler.html#new_fft",
    "href": "docs/hresampler.html#new_fft",
    "title": "HResampler",
    "section": "new_fft",
    "text": "new_fft\nnew_fft(sr_in: integer, sr_out: integer, chunk_size: integer, sub_chunks: integer, nbr_channels: integer, res_type: HResamplerType, dtype: HDataType) -&gt; HResampler\n\nCreates a new FFT type HResampler.\nSupports any of [fft_fixed_in, fft_fixed_in_out, fft_fixed_out] HResamplerType.\nThe resampling is done by FFTing the input data. The spectrum is then extended or truncated as well as multiplied with an antialiasing\nfilter before it’s inverse transformed to get the resampled waveforms.\n\n\nfft_fixed_in\nA synchronous resampler that needs a fixed number of audio frames for input and returns a variable number of frames.\n\nfft_fixed_in_out\nA synchronous resampler that accepts a fixed number of audio frames for input and returns a fixed number of frames.\n\nfft_fixed_out\nA synchronous resampler that needs a fixed number of audio frames for input and returns a variable number of frames.\n\n\n\nArguments\n\nsr_in\nThe input sampling rate in hz.\n\nsr_out\nThe output sampling rate in hz.\n\nchunk_size\nChunks size of input or output data in frames.\nIt can be used as input or output, depending on HResamplerType.\n\nsub_chunks\nDesired number of subchunks for processing, actual number may be different.\n\nnbr_channels\nNumber of channels in input and output.\nMust be the same number of channels as the HAudio that will be processed by the HResampler.\n\nres_type\nAn HResamplerType to indicate which type of HResampler to be created.\n\ndtype\nA float HDataType to indicate the dtype that the HResampler will be working with.\nMust be the same as the HAudio’s dtype that will be processed by the HResampler.\n\n\n\n\nReturns\nA FFT type HResampler.\n\n\n\nExamples\nsr_in = 48000L\nsr_out = 44100L\nchunk_size = 1024L\nsub_chunks = 2L\nnbr_channels = 2L\nres_type = HResamplerType$fft_fixed_in\ndtype = HDataType$float32\n\nhresampler = HResampler$new_fft(sr_in, sr_out, chunk_size, sub_chunks, nbr_channels, res_type, dtype)"
  },
  {
    "objectID": "docs/hresampler.html#new_sinc",
    "href": "docs/hresampler.html#new_sinc",
    "title": "HResampler",
    "section": "new_sinc",
    "text": "new_sinc\nnew_sinc(resample_ratio: double, max_resample_ratio_relative: double, parameters: HSincInterpolationParams, chunk_size: integer, nchannels: integer, res_type: HResamplerType, dtype: HDataType) -&gt; HResampler\n\nCreates a new Sinc type HResampler.\nSupports any of [sinc_fixed_in, sinc_fixed_out] HResamplerType.\nThe resampling is done by creating a number of intermediate points (defined by oversampling_factor) by sinc interpolation.\nThe new samples are then calculated by interpolating between these points.\n\n\nsinc_fixed_in\nAn asynchronous resampler that accepts a fixed number of audio frames for input and returns a variable number of frames.\n\nsinc_fixed_out\nAn asynchronous resampler that accepts a variable number of audio frames for input nad returns a fixed number of frames.\n\n\n\nArguments\n\nresample_ratio\nThe output’s sampling rate divided by the input’s sampling rate.\n\nmax_resample_ratio_relative\nMaximum ratio that can be set with set_resample_ratio relative to resample_ratio, must be &gt;= 1.0. The minimum relative\nratio is the reciprocal of the maximum. For example, with max_resample_ratio_relative of 10.0, the ratio can be set between\nresample_ratio * 10.0 and resample_ratio / 10.0.\n\nparameters\nAn HSincInterpolationParams. Parameters for interpolation.\n\nchunk_size\nChunks size of input or output data in frames.\n\nnchannels\nNumber of channels in input and output.\nMust be the same number of channels as the HAudio that will be processed by the HResampler.\n\nres_type\nAn HResamplerType. Indicates which type of HResampler to be created.\n\ndtype\nA float HDataType to indicate the dtype that the HResampler will be working with.\nMust be the same as the HAudio’s dtype that will be processed by the HResampler.\n\n\n\n\nReturns\nA Sinc type HResampler.\n\n\n\nExamples\nsr_in = 44100L\nsr_out = 48000L\nresample_ratio = sr_out / sr_in\nmax_resample_ratio_relative = 2\nhparams = HSincInterpolationParams$new(256, 0.95, 256, \"linear\", \"blackmanharris2\")\nchunk_size = 512L\nnchannels = 2L\nres_type = HResamplerType$sinc_fixed_out\ndtype = HDataType$float32\n\nres = HResampler$new_sinc(resample_ratio, max_resample_ratio_relative, hparams, chunk_size, nchannels, res_type, dtype)"
  },
  {
    "objectID": "docs/hresampler.html#new_fast",
    "href": "docs/hresampler.html#new_fast",
    "title": "HResampler",
    "section": "new_fast",
    "text": "new_fast\nnew_sinc(resample_ratio: double, max_resample_ratio_relative: double, pol_deg: HPolynomialDegree, chunk_size: integer, nchannels: integer, res_type: HResamplerType, dtype: HDataType) -&gt; HResampler\n\nCreates a new Fast type HResampler.\nSupports any of [fast_fixed_in, fast_fixed_out] HResamplerType.\nThe resampling is done by interpolating between the input samples by fitting polynomials.\nNote that no anti-aliasing filter is used. This makes it run considerably faster than the corresponding SincFixedIn, which performs anti-aliasing filtering. The price is that the resampling creates some artefacts\nin the output, mainly at higher frequencies. Use SincFixedIn if this can not be tolerated.\n\n\nfast_fixed_in\nAn asynchronous resampler that accepts a fixed number of audio frames for input and returns a variable number of frames.\n\nfast_fixed_out\nAn asynchronous resampler that accepts a variable number of audio frames for input nad returns a fixed number of frames.\n\n\n\nArguments\n\nresample_ratio\nThe output’s sampling rate divided by the input’s sampling rate.\n\nmax_resample_ratio_relative\nMaximum ratio that can be set with set_resample_ratio relative to resample_ratio, must be &gt;= 1.0. The minimum relative\nratio is the reciprocal of the maximum. For example, with max_resample_ratio_relative of 10.0, the ratio can be set between\nresample_ratio * 10.0 and resample_ratio / 10.0.\n\npol_deg\nAn HPolynomialDegree. Used to select the polynomial degree for interpolation.\n\nchunk_size\nChunks size of input or output data in frames.\n\nnchannels\nNumber of channels in input and output.\nMust be the same number of channels as the HAudio that will be processed by the HResampler.\n\nres_type\nAn HResamplerType. Indicates which type of HResampler to be created.\n\ndtype\nA float HDataType to indicate the dtype that the HResampler will be working with.\nMust be the same as the HAudio’s dtype that will be processed by the HResampler.\n\n\n\n\nReturns\nA Fast type HResampler.\n\n\n\nExamples\nsr_in = 44100L\nsr_out = 48000L\nresample_ratio = sr_out / sr_in\nmax_resample_ratio_relative = 2\npol_deg = HPolynomialDegree$linear\nchunk_size = 512L\nnchannels = 2L\nres_type = HResamplerType$fast_fixed_out\ndtype = HDataType$float32\n\nres = HResampler$new_fast(resample_ratio, max_resample_ratio_relative, pol_deg, chunk_size, nchannels, res_type, dtype)"
  },
  {
    "objectID": "docs/hresampler.html#process",
    "href": "docs/hresampler.html#process",
    "title": "HResampler",
    "section": "process",
    "text": "process\nprocess(haudio: HAudio, sr_out: integer)  source \n\nProcess the resampler, changing the HAudio’s sampling rate.\n\n\nArguments\n\nhaudio\nThe HAudio that will have it’s sampling rate converted.\n\nsr_out\nThe output sampling rate in hz.\n\n\n\n\nExamples\ndata = matrix(0, nrow = 512, ncol = 2)\nhaudio = HAudio$new_from_values(data, 44100, dtype = HDataType$float64)\nhparams = HSincInterpolationParams$new(256L, 0.95, 256L, \"linear\", \"blackmanharris2\")\nres = HResampler$new_sinc(48000L / 44100L, 2, hparams, 512L, 2L, HResamplerType$sinc_fixed_in, HDataType$float64)\nres$process(haudio, sr_out = 48000)"
  },
  {
    "objectID": "docs/hresampler.html#set_resample_ratio",
    "href": "docs/hresampler.html#set_resample_ratio",
    "title": "HResampler",
    "section": "set_resample_ratio",
    "text": "set_resample_ratio\nset_resample_ratio(new_ratio: double, ramp: bool)  source \n\nUpdate the resample ratio.\nFor asynchronous resamplers, the ratio must be within original / maximum to original * maximum, where original and maximum are the resampling ratios that were provided to the constructor. Trying to set the ratio outside these bounds will return an error.\nFor synchronous resamplers, this will always return an error.\n\n\nArguments\n\nnew_ratio\nThe new resample_ratio to be set.\n\nramp\nIf TRUE, the ratio will be ramped from the old to the new value during processing of the next chunk. This allows smooth transitions from one ratio to another. If ramp is false, the new ratio will be applied from the start of the next chunk.\n\n\n\n\nExamples\ndata = matrix(0, nrow = 512, ncol = 2)\nhaudio = HAudio$new_from_values(data, 44100, dtype = HDataType$float64)\nhparams = HSincInterpolationParams$new(256L, 0.95, 256L, \"linear\", \"blackmanharris2\")\nres = HResampler$new_sinc(48000L / 44100L, 2, hparams, 512L, 2L, HResamplerType$sinc_fixed_in, HDataType$float64)\nres$set_resample_ratio(1, FALSE)"
  },
  {
    "objectID": "docs/hresampler.html#set_resample_ratio_relative",
    "href": "docs/hresampler.html#set_resample_ratio_relative",
    "title": "HResampler",
    "section": "set_resample_ratio_relative",
    "text": "set_resample_ratio_relative\nset_resample_ratio_relative(rel_ratio: double, ramp: bool)  source \n\nUpdate the resample ratio as a factor relative to the original one.\nFor asynchronous resamplers, the relative ratio must be within 1 / maximum to maximum, where maximum is the maximum resampling ratio that was provided to the constructor. Trying to set the ratio outside these bounds will return an error.\nHigher ratios above 1.0 slow down the output and lower the pitch. Lower ratios below 1.0 speed up the output and raise the pitch.\nFor synchronous resamplers, this will always return an error.\n\n\nArguments\n\nrel_ratio\nA factor to update the resample_ratio relative to the original one.\n\nramp\nIf TRUE, the ratio will be ramped from the old to the new value during processing of the next chunk. This allows smooth transitions from one ratio to another. If ramp is false, the new ratio will be applied from the start of the next chunk.\n\n\n\n\nExamples\ndata = matrix(0, nrow = 512, ncol = 2)\nhaudio = HAudio$new_from_values(data, 44100, dtype = HDataType$float64)\nhparams = HSincInterpolationParams$new(256L, 0.95, 256L, \"linear\", \"blackmanharris2\")\nres = HResampler$new_sinc(48000L / 44100L, 2, hparams, 512L, 2L, HResamplerType$sinc_fixed_in, HDataType$float64)\nres$set_resample_ratio_relative(0.5, FALSE)"
  },
  {
    "objectID": "docs/hresampler.html#reset",
    "href": "docs/hresampler.html#reset",
    "title": "HResampler",
    "section": "reset",
    "text": "reset\nreset()  source \n\nReset the resampler state and clear all internal buffers.\n\n\nExamples\nsr_in = 44100L\nsr_out = 48000L\nresample_ratio = sr_out / sr_in\nmax_resample_ratio_relative = 2\npol_deg = HPolynomialDegree$linear\nchunk_size = 512L\nnchannels = 2L\nres_type = HResamplerType$fast_fixed_out\ndtype = HDataType$float32\n\nres = HResampler$new_fast(resample_ratio, max_resample_ratio_relative, pol_deg, chunk_size, nchannels, res_type, dtype)\nres$reset()"
  },
  {
    "objectID": "docs/hresampler.html#res_type",
    "href": "docs/hresampler.html#res_type",
    "title": "HResampler",
    "section": "res_type",
    "text": "res_type\nres_type() -&gt; HResamplerType  source \n\nGets the HResampler’s type.\n\n\nReturns\nAn HResamplerType.\n\n\nExamples\nsr_in = 44100L\nsr_out = 48000L\nresample_ratio = sr_out / sr_in\nmax_resample_ratio_relative = 2\npol_deg = HPolynomialDegree$linear\nchunk_size = 512L\nnchannels = 2L\nres_type = HResamplerType$fast_fixed_out\ndtype = HDataType$float32\n\nres = HResampler$new_fast(resample_ratio, max_resample_ratio_relative, pol_deg, chunk_size, nchannels, res_type, dtype)\nres$res_type()"
  },
  {
    "objectID": "docs/hresampler.html#dtype",
    "href": "docs/hresampler.html#dtype",
    "title": "HResampler",
    "section": "dtype",
    "text": "dtype\ndtype() -&gt; HDataType  source \n\nGets the HResampler’s dtype.\n\nReturns\nAn HDataType.\n\n\nExamples\nsr_in = 44100L\nsr_out = 48000L\nresample_ratio = sr_out / sr_in\nmax_resample_ratio_relative = 2\npol_deg = HPolynomialDegree$linear\nchunk_size = 512L\nnchannels = 2L\nres_type = HResamplerType$fast_fixed_out\ndtype = HDataType$float32\n\nres = HResampler$new_fast(resample_ratio, max_resample_ratio_relative, pol_deg, chunk_size, nchannels, res_type, dtype)\nres$dtype()"
  },
  {
    "objectID": "docs/hresampler.html#print",
    "href": "docs/hresampler.html#print",
    "title": "HResampler",
    "section": "print",
    "text": "print\nprint()  source \n\nPrint the HResampler.\nDifferently from R’s normal behaviour, print doesn’t return the value invisibly.\n\n\nExamples\nsr_in = 44100L\nsr_out = 48000L\nresample_ratio = sr_out / sr_in\nmax_resample_ratio_relative = 2\npol_deg = HPolynomialDegree$linear\nchunk_size = 512L\nnchannels = 2L\nres_type = HResamplerType$fast_fixed_out\ndtype = HDataType$float32\n\nres = HResampler$new_fast(resample_ratio, max_resample_ratio_relative, pol_deg, chunk_size, nchannels, res_type, dtype)\nres$print()\n\n# or similarly:\nprint(res)"
  },
  {
    "objectID": "docs/hresamplertype.html",
    "href": "docs/hresamplertype.html",
    "title": "HResamplerType",
    "section": "",
    "text": "A resampler type representation.\nSupports FftFixedIn, FftFixedInOut, FftFixedOut, SincFixedIn and SincFixedOut types."
  },
  {
    "objectID": "docs/hresamplertype.html#fft_fixed_in",
    "href": "docs/hresamplertype.html#fft_fixed_in",
    "title": "HResamplerType",
    "section": "fft_fixed_in",
    "text": "fft_fixed_in\nfft_fixed_in -&gt; HResamplerType  source \n\nCreates a FftFixedIn HResamplerType.\n\n\nReturns\nAn HResamplerType.\n\n\n\nExamples\nhresamplertype = HResamplerType$fft_fixed_in"
  },
  {
    "objectID": "docs/hresamplertype.html#fft_fixed_in_out",
    "href": "docs/hresamplertype.html#fft_fixed_in_out",
    "title": "HResamplerType",
    "section": "fft_fixed_in_out",
    "text": "fft_fixed_in_out\nfft_fixed_in_out -&gt; HResamplerType  source \n\nCreates a FftFixedInOut HResamplerType.\n\n\nReturns\nAn HResamplerType.\n\n\n\nExamples\nhresamplertype = HResamplerType$fft_fixed_in_out"
  },
  {
    "objectID": "docs/hresamplertype.html#fft_fixed_out",
    "href": "docs/hresamplertype.html#fft_fixed_out",
    "title": "HResamplerType",
    "section": "fft_fixed_out",
    "text": "fft_fixed_out\nfft_fixed_out -&gt; HResamplerType  source \n\nCreates a FftFixedOut HResamplerType.\n\n\nReturns\nAn HResamplerType.\n\n\n\nExamples\nhresamplertype = HResamplerType$fft_fixed_out"
  },
  {
    "objectID": "docs/hresamplertype.html#sinc_fixed_in",
    "href": "docs/hresamplertype.html#sinc_fixed_in",
    "title": "HResamplerType",
    "section": "sinc_fixed_in",
    "text": "sinc_fixed_in\nsinc_fixed_in -&gt; HResamplerType  source \n\nCreates a SincFixedIn HResamplerType.\n\n\nReturns\nAn HResamplerType.\n\n\n\nExamples\nhresamplertype = HResamplerType$sinc_fixed_in"
  },
  {
    "objectID": "docs/hresamplertype.html#sinc_fixed_out",
    "href": "docs/hresamplertype.html#sinc_fixed_out",
    "title": "HResamplerType",
    "section": "sinc_fixed_out",
    "text": "sinc_fixed_out\nsinc_fixed_out -&gt; HResamplerType  source \n\nCreates a SincFixedOut HResamplerType.\n\n\nReturns\nAn HResamplerType.\n\n\n\nExamples\nhresamplertype = HResamplerType$sinc_fixed_out"
  },
  {
    "objectID": "docs/hresamplertype.html#fast_fixed_in",
    "href": "docs/hresamplertype.html#fast_fixed_in",
    "title": "HResamplerType",
    "section": "fast_fixed_in",
    "text": "fast_fixed_in\nfast_fixed_in -&gt; HResamplerType  source \n\nCreates a FastFixedIn HResamplerType.\n\n\nReturns\nAn HResamplerType.\n\n\n\nExamples\nhresamplertype = HResamplerType$fast_fixed_in"
  },
  {
    "objectID": "docs/hresamplertype.html#fast_fixed_out",
    "href": "docs/hresamplertype.html#fast_fixed_out",
    "title": "HResamplerType",
    "section": "fast_fixed_out",
    "text": "fast_fixed_out\nfast_fixed_out -&gt; HResamplerType  source \n\nCreates a FastFixedOut HResamplerType.\n\n\nReturns\nAn HResamplerType.\n\n\n\nExamples\nhresamplertype = HResamplerType$fast_fixed_out"
  },
  {
    "objectID": "docs/hresamplertype.html#print",
    "href": "docs/hresamplertype.html#print",
    "title": "HResamplerType",
    "section": "print",
    "text": "print\nprint()  source \n\nPrints the HResamplerType.\nDifferently from R’s behaviour, print doesn’t return the value invisibly.\n\n\nExamples\nhresamplertype = HResamplerType$sinc_fixed_in\nhresamplertype$print()\n\n# or similarly:\nprint(hresamplertype)"
  },
  {
    "objectID": "docs/hresamplertype.html#eq",
    "href": "docs/hresamplertype.html#eq",
    "title": "HResamplerType",
    "section": "eq",
    "text": "eq\neq(other: HResamplerType) -&gt; bool  source \n\nEquality with another HResamplerType.\n\nArguments\n\nother\nAn HResamplerType.\n\n\n\n\nReturns\nA bool.\n\n\nExamples\nhresamplertype1 = HResamplerType$sinc_fixed_in\nhresamplertype2 = HResamplerType$sinc_fixed_in\nhresamplertype1$eq(hresamplertype2) # TRUE\n\n# or similarly:\nhresamplertype1 == hresamplertype2"
  },
  {
    "objectID": "docs/hresamplertype.html#ne",
    "href": "docs/hresamplertype.html#ne",
    "title": "HResamplerType",
    "section": "ne",
    "text": "ne\nne(other: HResamplerType) -&gt; bool  source \n\nDifference with another HResamplerType.\n\nArguments\n\nother\nAn HResamplerType.\n\n\n\n\nReturns\nA bool.\n\n\nExamples\nhresamplertype1 = HResamplerType$sinc_fixed_in\nhresamplertype2 = HResamplerType$sinc_fixed_in\nhresamplertype1$ne(hresamplertype2) # FALSE\n\n# or similarly:\nhresamplertype1 != hresamplertype2"
  },
  {
    "objectID": "docs/hwindow.html",
    "href": "docs/hwindow.html",
    "title": "HWindow",
    "section": "",
    "text": "A collection of window functions."
  },
  {
    "objectID": "docs/hwindow.html#barthann",
    "href": "docs/hwindow.html#barthann",
    "title": "HWindow",
    "section": "barthann",
    "text": "barthann\nbarthann(npoints: integer, sym: bool, dtype: HDataType) -&gt; HArray  source \n\nReturns a modified Bartlett-Hann window.\n\nThe maximum value is normalized to 1 (though the value 1 does not appear if npoints is even and window_type is symmetric).\n\n\nArguments\n\nnpoints\nAn integer. Number of points in the output window.\n\nsym\nA bool.\nWhen TRUE, generates a symmetric window, for use in filter design.\nWhen FALSE, generates a periodic window, for use in spectral analysis.\n\ndtype\nAn HDataType to indicate which type of HArray to be created.\nMust be a float dtype.\n\n\n\n\nReturns\nAn HArray.\n\n\n\nExamples\nHWindow$barthann(npoints = 10L, sym = TRUE, dtype = HDataType$Float64)"
  },
  {
    "objectID": "docs/hwindow.html#bartlett",
    "href": "docs/hwindow.html#bartlett",
    "title": "HWindow",
    "section": "bartlett",
    "text": "bartlett\nbartlett(npoints: integer, sym: bool, dtype: HDataType) -&gt; HArray  source \n\n\\(w(n) = \\frac{2}{npoints-1} (\\frac{npoints-1}{2} - |n - \\frac{npoints-1}{2}|)\\)\nThe Bartlett window is very similar to a triangular window, except that the end points are at zero. It is often used in signal processing for tapering a signal, without generating too much ripple in the frequency domain.\n\nThe maximum value is normalized to 1 (though the value 1 does not appear if npoints is even and window_type is symmetric.\n\n\nArguments\n\nnpoints\nAn integer. Number of points in the output window.\n\nsym\nA bool.\nWhen TRUE, generates a symmetric window, for use in filter design.\nWhen FALSE, generates a periodic window, for use in spectral analysis.\n\ndtype\nAn HDataType to indicate which type of HArray to be created.\nMust be a float dtype.\n\n\n\n\nReturns\nAn HArray.\n\n\n\nExamples\nHWindow$bartlett(npoints = 10L, sym = TRUE, dtype = HDataType$Float64)"
  },
  {
    "objectID": "docs/hwindow.html#blackman",
    "href": "docs/hwindow.html#blackman",
    "title": "HWindow",
    "section": "blackman",
    "text": "blackman\nblackman(npoints: integer, sym: bool, dtype: HDataType) -&gt; HArray  source \n\nReturns a Blackman window.\n\n\\(w(n) = 0.42 - 0.5 \\cos(2\\pi n/npoints) + 0.08 \\cos(4\\pi n/npoints)\\)\nThe Blackman window is a taper formed by using the first three terms of a summation of cosines. It was designed to have close to the minimal leakage possible. It is close to optimal, only slightly worse than a Kaiser window.\n\nThe maximum value is normalized to 1 (though the value 1 does not appear if npoints is even and sym is TRUE).\n\nThe “exact Blackman” window was designed to null out the third and fourth sidelobes, but has discontinuities at the boundaries, resulting in a 6 dB/oct fall-off. This window is an approximation of the “exact” window, which does not null the sidelobes as well, but is smooth at the edges, improving the fall-off rate to 18 dB/oct.\n\nMost references to the Blackman window come from the signal processing literature, where it is used as one of many windowing functions for smoothing values. It is also known as an apodization (which means “removing the foot”, i.e. smoothing discontinuities at the beginning and end of the sampled signal) or tapering function. It is known as a “near optimal” tapering function, almost as good (by some measures) as the Kaiser window.\n\n\nArguments\n\nnpoints\nAn integer. Number of points in the output window.\n\nsym\nA bool.\nWhen TRUE, generates a symmetric window, for use in filter design.\nWhen FALSE, generates a periodic window, for use in spectral analysis.\n\ndtype\nAn HDataType to indicate which type of HArray to be created.\nMust be a float dtype.\n\n\n\n\nReturns\nAn HArray.\n\n\n\nExamples\nHWindow$blackman(npoints = 10L, sym = TRUE, dtype = HDataType$Float64)"
  },
  {
    "objectID": "docs/hwindow.html#blackmanharris",
    "href": "docs/hwindow.html#blackmanharris",
    "title": "HWindow",
    "section": "blackmanharris",
    "text": "blackmanharris\nblackmanharris(npoints: integer, sym: bool, dtype: HDataType) -&gt; HArray  source \n\nReturn a minimum 4-term Blackman-Harris window.\n\nThe maximum value is normalized to 1 (though the value 1 does not appear if npoints is even and window_type is symmetric.\n\n\nArguments\n\nnpoints\nAn integer. Number of points in the output window.\n\nsym\nA bool.\nWhen TRUE, generates a symmetric window, for use in filter design.\nWhen FALSE, generates a periodic window, for use in spectral analysis.\n\ndtype\nAn HDataType to indicate which type of HArray to be created.\nMust be a float dtype.\n\n\n\n\nReturns\nAn HArray.\n\n\n\nExamples\nHWindow$blackmanharris(npoints = 10L, sym = TRUE, dtype = HDataType$Float64)"
  },
  {
    "objectID": "docs/hwindow.html#bohman",
    "href": "docs/hwindow.html#bohman",
    "title": "HWindow",
    "section": "bohman",
    "text": "bohman\nbohman(npoints: integer, sym: bool, dtype: HDataType) -&gt; HArray  source \n\nReturns a Bohman window.\n\nThe maximum value is normalized to 1 (though the value 1 does not appear if npoints is even and window_type is symmetric).\n\n\nArguments\n\nnpoints\nAn integer. Number of points in the output window.\n\nsym\nA bool.\nWhen TRUE, generates a symmetric window, for use in filter design.\nWhen FALSE, generates a periodic window, for use in spectral analysis.\n\ndtype\nAn HDataType to indicate which type of HArray to be created.\nMust be a float dtype.\n\n\n\n\nReturns\nAn HArray.\n\n\n\nExamples\nHWindow$bohman(npoints = 10L, sym = TRUE, dtype = HDataType$Float64)"
  },
  {
    "objectID": "docs/hwindow.html#boxcar",
    "href": "docs/hwindow.html#boxcar",
    "title": "HWindow",
    "section": "boxcar",
    "text": "boxcar\nboxcar(npoints: integer, dtype: HDataType) -&gt; HArray  source \n\nReturns a boxcar or rectangular window.\n\nAlso known as a rectangular window or Dirichlet window, this is equivalent to no window at all.\n\n\nArguments\n\nnpoints\nAn integer. Number of points in the output window.\n\ndtype\nAn HDataType to indicate which type of HArray to be created.\nMust be a float dtype.\n\n\n\n\nReturns\nAn HArray.\n\n\n\nExamples\nHWindow$boxcar(npoints = 10L, dtype = HDataType$Float64)"
  },
  {
    "objectID": "docs/hwindow.html#cosine",
    "href": "docs/hwindow.html#cosine",
    "title": "HWindow",
    "section": "cosine",
    "text": "cosine\ncosine(npoints: integer, sym: bool, dtype: HDataType) -&gt; HArray  source \n\nReturns a window with a simple cosine shape.\n\nThe maximum value is normalized to 1 (though the value 1 does not appear if npoints is even and window_type is symmetric).\n\n\nArguments\n\nnpoints\nAn integer. Number of points in the output window.\n\nsym\nA bool.\nWhen TRUE, generates a symmetric window, for use in filter design.\nWhen FALSE, generates a periodic window, for use in spectral analysis.\n\ndtype\nAn HDataType to indicate which type of HArray to be created.\nMust be a float dtype.\n\n\n\n\nReturns\nAn HArray.\n\n\n\nExamples\nHWindow$cosine(npoints = 10L, sym = TRUE, dtype = HDataType$Float64)"
  },
  {
    "objectID": "docs/hwindow.html#hann",
    "href": "docs/hwindow.html#hann",
    "title": "HWindow",
    "section": "hann",
    "text": "hann\nhann(npoints: integer, sym: bool, dtype: HDataType) -&gt; HArray  source \n\nReturns a Hann window.\n\n\\(w(n) = 0.5 - 0.5 \\cos\\left(\\frac{2\\pi{n}}{npoints-1}\\right) \\qquad 0 \\leq n \\leq npoints-1\\)\nThe maximum value is normalized to 1 (though the value 1 does not appear if npoints is even and window_type is symmetric.\n\nThe Hann window is a taper formed by using a raised cosine or sine-squared with ends that touch zero.\n\n\nArguments\n\nnpoints\nAn integer. Number of points in the output window.\n\nsym\nA bool.\nWhen TRUE, generates a symmetric window, for use in filter design.\nWhen FALSE, generates a periodic window, for use in spectral analysis.\n\ndtype\nAn HDataType to indicate which type of HArray to be created.\nMust be a float dtype.\n\n\n\n\nReturns\nAn HArray.\n\n\n\nExamples\nHWindow$hann(npoints = 10L, sym = TRUE, dtype = HDataType$Float64)"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Harmonium",
    "section": "",
    "text": "Harmonium is an audio interface inspired by Python’s librosa.\n\n\nBasic usage\nLoad the library\nlibrary(harmonium)\nCreate an haudio from an existing matrix\nvalues = matrix(c(1,2,3,4,5,6,7,8,9,10,11,12), ncol = 2)\ndtype = HDataType$float64\nhaudio = HAudio$new_from_values(values = values, sr = 3L, dtype = dtype)\nprint(haudio)\nOr create an haudio from an audio file\nhaudio = HAudio$new_from_file(fpath = \"file.wav\", dtype = dtype)\nprint(haudio)\nVerify the audio dimensions\nhaudio$len()\nhaudio$nchannels()\nhaudio$nframes()\nGet the sampling rate\nhaudio$sr()\nVerify the data type\nhaudio$dtype()\nConvert to an R matrix\nhaudio$collect()\nOr do a zero-copy conversion to an R’s arrow array\narrow::as_arrow_array(haudio$as_hmatrix())\nConvert to mono\nhaudio$as_mono()\nResample the haudio\nsr_in = haudio$sr()\nsr_out = 22050L\nnbr_channels = haudio$nchannels()\ndtype = HDataType$float64\nres_type = HResamplerType$fft_fixed_in\nresampler = HResampler$new_fft(sr_in = sr_in, sr_out = sr_out, nbr_channels = nbr_channels, res_type = res_type)\nhresampler$process(haudio, sr_out = sr_out, dtype = dtype)\nPlay the haudio\nhaudiosink = HAudioSink$new()\nhaudiosink$append_from_haudio(haudio)\nOr play directly from the file\nhaudiosink$append_from_file(\"file.wav\")\nGet the number of audios to be played\nhaudiosink$len()\nDouble the audio volume and the playback speed\nhaudiosink$set_volume(2)\nhaudiosink$set_speed(2)\nPause the playback and confirms it is paused\nhaudiosink$pause()\nhaudiosink$is_paused()\nIt is also possible to get metadata from an audio file\nmetatadatype = HMetadataType$text\nHFile$metadata_from_file(\"file.wav\", metatadatype)\nAnd to get some audio parameters directly from a file\nparams = HFile$get_params_from_file(\"file.wav\")\nsr = params[[1]]\nnframes = params[[2]]\nnchannels = params[[3]]\nduration = params[[4]]"
  }
]